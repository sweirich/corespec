<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Metalib.CoqUniquenessTac</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Metalib.CoqUniquenessTac</h1>

<div class="code">

<br/>
</div>

<div class="doc">
Provides a tactic for proving the uniqueness of objects. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">Coq.Lists.List</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.Eqdep_dec.html#"><span class="id" title="library">Coq.Logic.Eqdep_dec</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.omega.Omega.html#"><span class="id" title="library">Coq.omega.Omega</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab75"></a><h1 class="section">Auxiliary definitions</h1>

<div class="paragraph"> </div>

 From a list of types, compute the type of a curried function whose
    arguments are those types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="arrow"><span class="id" title="definition">arrow</span></a> (<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">res</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Metalib.CoqUniquenessTac.html#res"><span class="id" title="variable">res</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> <span class="id" title="var">ys</span> ⇒ <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#arrow"><span class="id" title="definition">arrow</span></a> <span class="id" title="var">ys</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#res"><span class="id" title="variable">res</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
From a list of types, compute the type of a heterogeneous list
    whose elements are of those types.  Heterogeneous lists are
    represented as nested tuples. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="tuple"><span class="id" title="definition">tuple</span></a> (<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> <span class="id" title="var">ys</span> ⇒ (<span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <span class="id" title="var">ys</span>)%<span class="id" title="var">type</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Apply a curried function to a heterogeneous list of arguments. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="apply_tuple"><span class="id" title="definition">apply_tuple</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">res</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#arrow"><span class="id" title="definition">arrow</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#res"><span class="id" title="variable">res</span></a>) (<span class="id" title="var">arg</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Metalib.CoqUniquenessTac.html#res"><span class="id" title="variable">res</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">as</span> [ | ? ? <span class="id" title="var">IH</span> ]; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">IH</span> (<span class="id" title="var">f</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#fst"><span class="id" title="definition">fst</span></a> <span class="id" title="var">arg</span>)) (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <span class="id" title="var">arg</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Reverse a list onto the given accumulator.  Compared to
    <span class="inlinecode"><span class="id" title="var">List.rev</span></span>, this definition simplifies the implementation of
    heterogeneous list reversal (see below). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="tr_list_rev"><span class="id" title="definition">tr_list_rev</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">acc</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> ⇒ <a class="idref" href="Metalib.CoqUniquenessTac.html#acc"><span class="id" title="variable">acc</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> <span class="id" title="var">ys</span> ⇒ <a class="idref" href="Metalib.CoqUniquenessTac.html#tr_list_rev"><span class="id" title="definition">tr_list_rev</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a> <span class="id" title="var">ys</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="var">y</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#acc"><span class="id" title="variable">acc</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#tr_list_rev"><span class="id" title="definition">tr_list_rev</span></a> [ <span class="id" title="var">A</span> ].<br/>

<br/>
</div>

<div class="doc">
Reverse a list. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="list_rev"><span class="id" title="definition">list_rev</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#tr_list_rev"><span class="id" title="definition">tr_list_rev</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>.<br/>

<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> [ <span class="id" title="var">A</span> ].<br/>

<br/>
</div>

<div class="doc">
Reverse a heterogeneous list onto the given accumulator. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tr_tuple_rev"><span class="id" title="definition">tr_tuple_rev</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">ab</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">acc</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">acc'</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#acc"><span class="id" title="variable">acc</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#tr_list_rev"><span class="id" title="definition">tr_list_rev</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#acc"><span class="id" title="variable">acc</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">acc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">as</span> [ | ? ? <span class="id" title="var">IH</span> ]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">acc</span> <span class="id" title="var">acc'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">acc'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">IH</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <span class="id" title="var">ab</span>) (<span class="id" title="var">a</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#0a8150c3c4df34d205c5ed9a427e2ed5"><span class="id" title="notation">::</span></a> <span class="id" title="var">acc</span>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#fst"><span class="id" title="definition">fst</span></a> <span class="id" title="var">ab</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">acc'</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Reverse a heterogenous list. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tuple_rev"><span class="id" title="definition">tuple_rev</span></a><br/>
&nbsp;&nbsp;(<span class="id" title="var">xs</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">ab</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a>) : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#tr_tuple_rev"><span class="id" title="definition">tr_tuple_rev</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#ab"><span class="id" title="variable">ab</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab76"></a><h1 class="section">Auxiliary facts</h1>

<div class="paragraph"> </div>

 This is the minimum set of facts about decidable equality that the
    <span class="inlinecode"><span class="id" title="var">uniqueness</span></span> tactic (defined below) requires. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_unit_dec"><span class="id" title="lemma">eq_unit_dec</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">decide</span> <span class="id" title="var">equality</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_pair_dec"><span class="id" title="lemma">eq_pair_dec</span></a> : <span class="id" title="keyword">∀</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#B"><span class="id" title="variable">B</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">+</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">{</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Specif.html#5bf2050e90b21ebc82dc5463d1ba338e"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">decide</span> <span class="id" title="var">equality</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">eq_unit_dec</span> <span class="id" title="var">eq_pair_dec</span> : <span class="id" title="var">eq_dec</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab77"></a><h1 class="section">Tactic for proving the uniqueness of objects</h1>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">uniqueness</span></span> analyzes goals of the form <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#C"><span class="id" title="variable">C</span></a></span> <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#x1"><span class="id" title="variable">x1</span></a></span> <span class="inlinecode">..</span> <span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#q"><span class="id" title="variable">q</span></a></span> by
    destructing <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#q"><span class="id" title="variable">q</span></a></span> using the <span class="inlinecode"><span class="id" title="tactic">case</span></span> tactic.  It is mainly useful when
    <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#q"><span class="id" title="variable">q</span></a></span> is an object of an indexed inductive type <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#Q"><span class="id" title="variable">Q</span></a></span>, since it
    generalizes the goal such that <span class="inlinecode"><span class="id" title="tactic">case</span></span> will succeed.  The argument
    should be the number of indices to <span class="inlinecode"><a class="idref" href="Metalib.CoqFSetDecide.html#Q"><span class="id" title="variable">Q</span></a></span>, and the indices should not
    depend on each other.

<div class="paragraph"> </div>

    Subgoals generated by the tactic will require one of three things:
    showing that the goal state is impossible, proving that equality
    at some type is decidable, and proving that any two objects of
    some type are equal.  The tactic <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><a class="idref" href="Metalib.MetatheoryAtom.html#Atom.eq_dec"><span class="id" title="definition">eq_dec</span></a></span> is used to
    discharge subgoals of the second form.  The tactic <span class="inlinecode"><span class="id" title="tactic">auto</span></span> is used
    to discharge subgoals of the third form. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">uniqueness</span> <span class="id" title="var">icount</span> :=<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Expose the conclusion. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>;<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
If the right hand side looks like a function application, flip
      the equality around.  This is merely so that the remainder of
      this tactic can assume that the goal is in a certain form. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">try</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">f</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">symmetry</span> <span class="id" title="keyword">end</span>);<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Record the proof on the left hand side of the equality. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">lhs</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">lhs</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">lhs</span>) <span class="id" title="keyword">end</span> <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Record the proof on the right hand side of the equality. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rhs</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> ?<span class="id" title="var">rhs</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">rhs</span>) <span class="id" title="keyword">end</span> <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Record the sort of the predicate. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">sort</span> := <span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">rhs</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">pred</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">pred</span> <span class="id" title="keyword">with</span> ?<span class="id" title="var">sort</span> ⇒ <span class="id" title="var">sort</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Extract out the predicate applied only to its parameters.  We
      use the value of <span class="inlinecode"><span class="id" title="var">icount</span></span> to determine the number of indices. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">get_pred_type</span> <span class="id" title="var">i</span> <span class="id" title="var">pred</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <span class="id" title="var">pred</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> ?<span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">pred</span> <span class="id" title="keyword">with</span> ?<span class="id" title="var">f</span> ?<span class="id" title="var">x</span> ⇒ <span class="id" title="var">get_pred_type</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">pred</span> := <span class="id" title="var">get_pred_type</span> <span class="id" title="var">icount</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">rhs</span>) <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Extract out the types of the predicate's indices.  We use the
      value of <span class="inlinecode"><span class="id" title="var">icount</span></span> to determine the number of indices. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">get_ind_types</span> <span class="id" title="var">i</span> <span class="id" title="var">pred</span> <span class="id" title="var">acc</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <span class="id" title="var">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> ?<span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">pred</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">f</span> ?<span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">let</span> <span class="id" title="var">ind</span> := <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">x</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">get_ind_types</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> (@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#cons"><span class="id" title="constructor">cons</span></a> <span class="id" title="keyword">Type</span> <span class="id" title="var">ind</span> <span class="id" title="var">acc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">ind_types</span> := <span class="id" title="var">get_ind_types</span> <span class="id" title="var">icount</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">rhs</span>) (@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a> <span class="id" title="keyword">Type</span>) <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Extract out the predicate's indices.  We use the value of
      <span class="inlinecode"><span class="id" title="var">icount</span></span> to determine the number of indices. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">get_inds</span> <span class="id" title="var">i</span> <span class="id" title="var">pred</span> <span class="id" title="var">acc</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">i</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#O"><span class="id" title="constructor">O</span></a> ⇒ <span class="id" title="var">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> ?<span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">match</span> <span class="id" title="var">pred</span> <span class="id" title="keyword">with</span> ?<span class="id" title="var">f</span> ?<span class="id" title="var">x</span> ⇒ <span class="id" title="var">get_inds</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">acc</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">inds</span> := <span class="id" title="var">get_inds</span> <span class="id" title="var">icount</span> <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">rhs</span>) <span class="id" title="var">tt</span> <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
For technical reasons that will become clear later in this
      tactic, we record reversed versions of the list of types of the
      predicate's indices and of the list of indices. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rind_types</span> := <span class="id" title="keyword">constr</span>:(<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <span class="id" title="var">ind_types</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rinds</span> := <span class="id" title="keyword">constr</span>:(<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="var">ind_types</span> <span class="id" title="var">inds</span>) <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Now the real fun begins.  We need massage the goal so that it
      looks like <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#P"><span class="id" title="variable">P</span></a></span> <span class="inlinecode"><span class="id" title="var">index1</span></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">indexN</span></span> <span class="inlinecode"><a class="idref" href="Metalib.CoqUniquenessTac.html#rhs"><span class="id" title="variable">rhs</span></a></span>.  The trick is to define
      <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#P"><span class="id" title="variable">P</span></a></span> appropriately.  The definition of <span class="inlinecode"><span class="id" title="var">core</span></span> below is the first
      step in defining <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#P"><span class="id" title="variable">P</span></a></span>.  Compared to what we want, it is uncurried
      and the indices are in reverse order. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> (<span class="id" title="var">ainds</span> : <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">rhs</span>   : <a class="idref" href="Metalib.CoqUniquenessTac.html#apply_tuple"><span class="id" title="definition">apply_tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">sort</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pred</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="var">rind_types</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#ainds"><span class="id" title="variable">ainds</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">eqpf</span> : <span class="id" title="var">rinds</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#ainds"><span class="id" title="variable">ainds</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#apply_tuple"><span class="id" title="definition">apply_tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">sort</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pred</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="var">rind_types</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#ainds"><span class="id" title="variable">ainds</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_rect"><span class="id" title="definition">eq_rect</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rinds</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">rinds2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#apply_tuple"><span class="id" title="definition">apply_tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">sort</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pred</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="var">rind_types</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#rinds2"><span class="id" title="variable">rinds2</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#ainds"><span class="id" title="variable">ainds</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#eqpf"><span class="id" title="variable">eqpf</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#rhs"><span class="id" title="variable">rhs</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> := <span class="id" title="tactic">eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">core</span> <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Now, we take <span class="inlinecode"><span class="id" title="var">core</span></span> and curry it.  When we curry <span class="inlinecode"><span class="id" title="var">core</span></span>, we end
      up "reversing" the order of arguments.  Because they started out
      reversed, what we end up with is function that takes the
      predicate's indices in the correct order when compared to the
      predicate's elimination principle.

<div class="paragraph"> </div>

      Implementation note (BEA): I don't see how to arrive at this
      curried form with out going through the "reversed list" stage. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">curry</span> <span class="id" title="var">f</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">∀</span> <span class="id" title="var">_</span> : (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>), <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">∀</span> <span class="id" title="var">_</span> : (<span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>), <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">∀</span> <span class="id" title="var">_</span> : (<span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <span class="id" title="var">_</span>), <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">f'</span> := <span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="Metalib.CoqUniquenessTac.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="Metalib.CoqUniquenessTac.html#b"><span class="id" title="variable">b</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>) <span class="id" title="keyword">in</span> <span class="id" title="var">curry</span> <span class="id" title="var">f'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> := <span class="id" title="var">curry</span> <span class="id" title="var">core</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> := <span class="id" title="tactic">eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">core</span> <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Now we supply to <span class="inlinecode"><span class="id" title="var">core</span></span> the indices and the proof on the right
      hand side of the equality (the one we want to apply <span class="inlinecode"><span class="id" title="tactic">case</span></span> to). 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">apply_core</span> <span class="id" title="var">f</span> <span class="id" title="var">args</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">args</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> ⇒ <span class="id" title="keyword">constr</span>:(<span class="id" title="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a>?<span class="id" title="var">x</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> ?<span class="id" title="var">xs</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> ⇒ <span class="id" title="var">apply_core</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">xs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> := <span class="id" title="var">apply_core</span> <span class="id" title="var">core</span> <span class="id" title="var">inds</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">core</span> := <span class="id" title="keyword">constr</span>:(<span class="id" title="var">core</span> <span class="id" title="var">rhs</span>) <span class="id" title="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
In order to make <span class="inlinecode"><span class="id" title="var">core</span></span> convertible with the goal, we need to
      introduce an equality for the predicate's indices and generalize
      over that equality. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">change</span> <span class="id" title="var">lhs</span> <span class="id" title="keyword">with</span> (@<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_rect"><span class="id" title="definition">eq_rect</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple"><span class="id" title="definition">tuple</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rinds</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">rinds2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Metalib.CoqUniquenessTac.html#apply_tuple"><span class="id" title="definition">apply_tuple</span></a> (<a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a> <span class="id" title="var">rind_types</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">sort</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pred</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="var">rind_types</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#rinds2"><span class="id" title="variable">rinds2</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rinds</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#refl_equal"><span class="id" title="abbreviation">refl_equal</span></a> <span class="id" title="var">rinds</span>));<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#refl_equal"><span class="id" title="abbreviation">refl_equal</span></a> <span class="id" title="var">rinds</span>);<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
We now have everything we need in order to use the <span class="inlinecode"><span class="id" title="tactic">case</span></span> tactic. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">change</span> <span class="id" title="var">core</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">rhs</span>;<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
At this point, all that remains is to simplify everything.
      We begin by making sure all functions have reduced. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Metalib.CoqUniquenessTac.html#list_rev"><span class="id" title="definition">list_rev</span></a>, <a class="idref" href="Metalib.CoqUniquenessTac.html#tuple_rev"><span class="id" title="definition">tuple_rev</span></a> <span class="id" title="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">tr_list_rev</span> <span class="id" title="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">tr_tuple_rev</span> <span class="id" title="keyword">in</span> *;<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Next, we simplify the equality that we introduced earlier,
      checking for "obvious" contradictions in the process. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="keyword">in</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>; <span class="id" title="tactic">injection</span> <span class="id" title="var">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="tactic">progress</span> <span class="id" title="tactic">intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>);<br/>
&nbsp;&nbsp;<span class="id" title="tactic">subst</span>;<br/>
<br/>
&nbsp;&nbsp;</div>

<div class="doc">
All that is left now is to use <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.Eqdep_dec.html#eq_rect_eq_dec"><span class="id" title="lemma">eq_rect_eq_dec</span></a></span> to simplify
      occurrences of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#eq_rect"><span class="id" title="definition">eq_rect</span></a></span>.  Since we have an equality between
      constructors, we can use <span class="inlinecode"><span class="id" title="tactic">f_equal</span></span> to safely make progress from
      there.  We use <span class="inlinecode"><span class="id" title="tactic">auto</span></span> and <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><a class="idref" href="Metalib.MetatheoryAtom.html#Atom.eq_dec"><span class="id" title="definition">eq_dec</span></a></span> to clean up any
      subgoals. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">try</span> (<span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Logic.Eqdep_dec.html#eq_rect_eq_dec"><span class="id" title="lemma">eq_rect_eq_dec</span></a>; [ <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">auto</span> | <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">eq_dec</span> ]).<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>