<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Metalib.Metatheory</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Metalib.Metatheory</h1>

<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Arith.Arith.html#"><span class="id" title="library">Coq.Arith.Arith</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.FSets.FSets.html#"><span class="id" title="library">Coq.FSets.FSets</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#"><span class="id" title="library">Coq.Lists.List</span></a>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Metalib.AssocList.html#"><span class="id" title="library">Metalib.AssocList</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Metalib.CoqListFacts.html#"><span class="id" title="library">Metalib.CoqListFacts</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Metalib.LibTactics.html#"><span class="id" title="library">Metalib.LibTactics</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Metalib.MetatheoryAtom.html#"><span class="id" title="library">Metalib.MetatheoryAtom</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab108"></a><h1 class="section">Notations for finite sets of atoms</h1>

<div class="paragraph"> </div>

 Common set operations and constants may be written using more
    convenient notations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="2499d7a52e1fca683823149ce53018f0"><span class="id" title="notation">&quot;</span></a>E [=] F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.Equal"><span class="id" title="definition">AtomSetImpl.Equal</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="a09b9f73c6cd1db960bc01de33abf895"><span class="id" title="notation">&quot;</span></a>E [&lt;=] F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.Subset"><span class="id" title="definition">AtomSetImpl.Subset</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="2473ece9ad576f5f81f39e22ff1054b7"><span class="id" title="notation">&quot;</span></a>{}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.empty"><span class="id" title="axiom">AtomSetImpl.empty</span></a>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="0f1995ce79e7fbd9df26d8b9c2944d2d"><span class="id" title="notation">&quot;</span></a>{{  x  }}" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.singleton"><span class="id" title="axiom">AtomSetImpl.singleton</span></a> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="cc4b473ff9ec85e2231c386241202ee8"><span class="id" title="notation">&quot;</span></a>x `in` E" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.In"><span class="id" title="axiom">AtomSetImpl.In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_hs_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">&quot;</span></a>x `notin` E" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#611abc97cba304de784fa909dbdea1fa"><span class="id" title="notation">¬</span></a> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.In"><span class="id" title="axiom">AtomSetImpl.In</span></a> <span class="id" title="var">x</span> <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_hs_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="1e545c9ff2fca9b4a5741b8eeb20df3b"><span class="id" title="notation">&quot;</span></a>E `union` F" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.union"><span class="id" title="axiom">AtomSetImpl.union</span></a> <span class="id" title="var">E</span> <span class="id" title="var">F</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 65, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "E  `union`  '/' F")<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_hs_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We define some abbreviations for the empty set, singleton
    sets, and the union of two sets. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="add"><span class="id" title="abbreviation">add</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.add"><span class="id" title="axiom">AtomSetImpl.add</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="empty"><span class="id" title="abbreviation">empty</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.empty"><span class="id" title="axiom">AtomSetImpl.empty</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="remove"><span class="id" title="abbreviation">remove</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.remove"><span class="id" title="axiom">AtomSetImpl.remove</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="singleton"><span class="id" title="abbreviation">singleton</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.singleton"><span class="id" title="axiom">AtomSetImpl.singleton</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="union"><span class="id" title="abbreviation">union</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl.union"><span class="id" title="axiom">AtomSetImpl.union</span></a>.<br/>

<br/>
</div>

<div class="doc">
Open the notation scopes declared above. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_scope</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_hs_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab109"></a><h1 class="section">Environments</h1>

<div class="paragraph"> </div>

 We can use our implementation of association lists (in AssocList)
    to implement association lists whose keys are atoms.  Thanks to
    parameter inlining, the types in the instantiated functor will all
    use <span class="inlinecode"><a class="idref" href="Metalib.MetatheoryAtom.html#atom"><span class="id" title="abbreviation">atom</span></a></span> for the type for keys. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="keyword">Export</span> <a name="EnvImpl"><span class="id" title="module">EnvImpl</span></a> := <a class="idref" href="Metalib.AssocList.html#Make"><span class="id" title="module">AssocList.Make</span></a> <a class="idref" href="Metalib.MetatheoryAtom.html#Atom"><span class="id" title="module">Atom</span></a> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetImpl"><span class="id" title="module">AtomSetImpl</span></a>.<br/>

<br/>
</div>

<div class="doc">
We provide alternative names for the tactics on association lists
    to reflect our use of association lists for environments. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">simpl_env</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">simpl_alist</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "simpl_env" "in" <span class="id" title="var">hyp</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">simpl_alist</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "simpl_env" "in" "*" :=<br/>
&nbsp;&nbsp;<span class="id" title="var">simpl_alist</span> <span class="id" title="keyword">in</span> ×.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "rewrite_env" <span class="id" title="keyword">constr</span>(<span class="id" title="var">E</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">rewrite_alist</span> <span class="id" title="var">E</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "rewrite_env" <span class="id" title="keyword">constr</span>(<span class="id" title="var">E</span>) "in" <span class="id" title="var">hyp</span>(<span class="id" title="var">H</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">rewrite_alist</span> <span class="id" title="var">E</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "env" "induction" <span class="id" title="var">ident</span>(<span class="id" title="var">E</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">E</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "env" "induction" <span class="id" title="var">ident</span>(<span class="id" title="var">E</span>) "as" <span class="id" title="var">simple_intropattern</span>(<span class="id" title="var">P</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">alist</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">E</span> <span class="id" title="keyword">as</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
As an alternative to the <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">¬</span> <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#Make.BindsDerived.a"><span class="id" title="variable">a</span></a></span> notation, we also provide more
    list-like notation for writing association lists consisting of a
    single binding.

<div class="paragraph"> </div>

    Implementation note: The following notation overlaps with the
    standard recursive notation for lists, e.g., the one found in the
    Program library of Coq's standard library. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="c01a66427f9bf52c657b100125a95da8"><span class="id" title="notation">&quot;</span></a>[ x ]" := (<a class="idref" href="Metalib.Metatheory.html#one"><span class="id" title="definition">EnvImpl.one</span></a> <span class="id" title="var">x</span>) : <span class="id" title="var">env_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">env_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab110"></a><h1 class="section">Cofinite quantification</h1>

<div class="paragraph"> </div>

 Consider a rule <span class="inlinecode"><span class="id" title="var">H</span></span> (equivalently, constructor, lemma, etc.) whose
    type begins with <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Metalib.FSetExtra.html#L"><span class="id" title="variable">L</span></a>,</span> <span class="inlinecode">...</span> and contains hypotheses of the
    form <span class="inlinecode">(<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a>,</span> <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode"><a class="idref" href="Metalib.FSetExtra.html#L"><span class="id" title="variable">L</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode">...)</span>.

<div class="paragraph"> </div>

    The tactic <span class="inlinecode">(<span class="id" title="var">pick</span></span> <span class="inlinecode"><span class="id" title="tactic">fresh</span></span> <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><span class="id" title="var">excluding</span></span> <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#Make.BindsDerived.F"><span class="id" title="variable">F</span></a></span> <span class="inlinecode"><span class="id" title="var">and</span></span> <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">H</span>)</span> applies <span class="inlinecode"><span class="id" title="var">H</span></span> to
    the current goal, instantiating <span class="inlinecode"><span class="id" title="var">H</span></span>'s first argument (<span class="inlinecode"><a class="idref" href="Metalib.FSetExtra.html#L"><span class="id" title="variable">L</span></a></span>) with
    the finite set of atoms <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#Make.BindsDerived.F"><span class="id" title="variable">F</span></a></span>.  In each new subgoal of the form
    <span class="inlinecode">(<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a>,</span> <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#Make.BindsDerived.F"><span class="id" title="variable">F</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode">...)</span>, the atom <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a></span> is introduced as
    <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span>, and <span class="inlinecode">(<a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode"><a class="idref" href="Metalib.AssocList.html#Make.BindsDerived.F"><span class="id" title="variable">F</span></a>)</span> is introduced using a generated name.

<div class="paragraph"> </div>

    If we view <span class="inlinecode"><span class="id" title="var">H</span></span> as a rule that uses cofinite quantification, the
    tactic can be read as picking a sufficiently fresh atom to open a
    term with. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;"pick" "fresh" <span class="id" title="var">ident</span>(<span class="id" title="var">atom_name</span>)<br/>
&nbsp;&nbsp;"excluding" <span class="id" title="keyword">constr</span>(<span class="id" title="var">L</span>)<br/>
&nbsp;&nbsp;"and" "apply" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">first</span> [<span class="id" title="tactic">apply</span> (@<span class="id" title="var">H</span> <span class="id" title="var">L</span>) | <span class="id" title="tactic">eapply</span> (@<span class="id" title="var">H</span> <span class="id" title="var">L</span>)];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">∀</span> <span class="id" title="var">_</span>, <span class="id" title="var">_</span> <a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">notin</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">Fr</span> := <span class="id" title="tactic">fresh</span> "Fr" <span class="id" title="keyword">in</span> <span class="id" title="tactic">intros</span> <span class="id" title="var">atom_name</span> <span class="id" title="var">Fr</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| |- <span class="id" title="keyword">∀</span> <span class="id" title="var">_</span>, <span class="id" title="var">_</span> <a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">notin</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">fail</span> 1 "because" <span class="id" title="var">atom_name</span> "is already defined"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The following variant of the tactic excludes the set of atoms
    returned by the <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span> tactic.  Redefine <span class="inlinecode"><span class="id" title="var">gather_atoms</span></span> if
    you wish to modify the behavior of this tactic. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Tactic Notation</span><br/>
&nbsp;&nbsp;"pick" "fresh" <span class="id" title="var">ident</span>(<span class="id" title="var">atom_name</span>)<br/>
&nbsp;&nbsp;"and" "apply" <span class="id" title="keyword">constr</span>(<span class="id" title="var">H</span>)<br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">L</span> := <span class="id" title="var">gather_atoms</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">L</span> := <span class="id" title="var">beautify_fset</span> <span class="id" title="var">L</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">atom_name</span> <span class="id" title="var">excluding</span> <span class="id" title="var">L</span> <span class="id" title="var">and</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab111"></a><h1 class="section">Lemma aliases</h1>

<div class="paragraph"> </div>

 A number of useful lemmas are given standardized, if somewhat
    unintuitive, names.  Here, we define some intuitive aliases for
    them. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="uniq_one"><span class="id" title="abbreviation">uniq_one</span></a> := <a class="idref" href="Metalib.Metatheory.html#uniq_one_1"><span class="id" title="lemma">uniq_one_1</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="uniq_cons"><span class="id" title="abbreviation">uniq_cons</span></a> := <a class="idref" href="Metalib.Metatheory.html#uniq_cons_3"><span class="id" title="lemma">uniq_cons_3</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="uniq_app"><span class="id" title="abbreviation">uniq_app</span></a> := <a class="idref" href="Metalib.Metatheory.html#uniq_app_4"><span class="id" title="lemma">uniq_app_4</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="uniq_map"><span class="id" title="abbreviation">uniq_map</span></a> := <a class="idref" href="Metalib.Metatheory.html#uniq_map_2"><span class="id" title="lemma">uniq_map_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="binds_one"><span class="id" title="abbreviation">binds_one</span></a> := <a class="idref" href="Metalib.Metatheory.html#binds_one_3"><span class="id" title="lemma">binds_one_3</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="binds_cons"><span class="id" title="abbreviation">binds_cons</span></a> := <a class="idref" href="Metalib.Metatheory.html#binds_cons_3"><span class="id" title="lemma">binds_cons_3</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="binds_app_l"><span class="id" title="abbreviation">binds_app_l</span></a> := <a class="idref" href="Metalib.Metatheory.html#binds_app_2"><span class="id" title="lemma">binds_app_2</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="binds_app_r"><span class="id" title="abbreviation">binds_app_r</span></a> := <a class="idref" href="Metalib.Metatheory.html#binds_app_3"><span class="id" title="lemma">binds_app_3</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="binds_map"><span class="id" title="abbreviation">binds_map</span></a> := <a class="idref" href="Metalib.Metatheory.html#binds_map_2"><span class="id" title="lemma">binds_map_2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="notin_empty"><span class="id" title="abbreviation">notin_empty</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_empty_1"><span class="id" title="lemma">notin_empty_1</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="notin_add"><span class="id" title="abbreviation">notin_add</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_add_3"><span class="id" title="lemma">notin_add_3</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="notin_singleton"><span class="id" title="abbreviation">notin_singleton</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_singleton_2"><span class="id" title="lemma">notin_singleton_2</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="notin_union"><span class="id" title="abbreviation">notin_union</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_union_3"><span class="id" title="lemma">notin_union_3</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab112"></a><h1 class="section">Hints</h1>

<div class="paragraph"> </div>

 The next block of hints is to help <span class="inlinecode"><span class="id" title="tactic">auto</span></span> discharge many of the
    inequality and freshness goals that arise in programming language
    metatheory proofs.

<div class="paragraph"> </div>

    Implementation note (BEA): The <span class="inlinecode"><span class="id" title="var">eassumption</span></span> step is intended to
    address those cases where <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> tries to use a cofinite
    rule. The pattern goes something like this:

<div class="paragraph"> </div>

<ul class="doclist">
<li> Apply a cofinite rule with no idea what "<span class="inlinecode"><a class="idref" href="Metalib.FSetExtra.html#L"><span class="id" title="variable">L</span></a></span>" should be.
        This adds a hypothesis <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode">?1</span> to the context.

</li>
<li> Apply the IH.

</li>
<li> <span class="inlinecode"><span class="id" title="var">eassumption</span></span> resolves the <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode"><a class="idref" href="Metalib.FSetExtra.html#L"><span class="id" title="variable">L</span></a></span> obligation of
        the IH against the previously introduced <span class="inlinecode"><a class="idref" href="Metalib.MSetWeakNotin.html#Notin_fun.Lemmas.x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">`<a class="idref" href="Metalib.MSetExtra.html#Make.notin"><span class="id" title="definition">notin</span></a>`</span> <span class="inlinecode">?1</span>
        hypothesis.

</li>
</ul>

<div class="paragraph"> </div>

    This ensures that the <span class="inlinecode"><span class="id" title="tactic">autorewrite</span></span> step does not trigger an
    infinite loop. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">hint_extern_solve_notin</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="var">eassumption</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">autorewrite</span> <span class="id" title="keyword">with</span> <span class="id" title="var">rewr_dom</span> <span class="id" title="keyword">in</span> *;<br/>
&nbsp;&nbsp;<span class="id" title="var">destruct_notin</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">first</span> [ <span class="id" title="tactic">apply</span> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_union_3"><span class="id" title="lemma">notin_union_3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">apply</span> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_add_3"><span class="id" title="lemma">notin_add_3</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">apply</span> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_singleton_2"><span class="id" title="lemma">notin_singleton_2</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">apply</span> <a class="idref" href="Metalib.MetatheoryAtom.html#AtomSetNotin.notin_empty_1"><span class="id" title="lemma">notin_empty_1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];<br/>
&nbsp;&nbsp;<span class="id" title="tactic">try</span> <span class="id" title="tactic">tauto</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#bf4ebde00e5e9b74eb68426b182981ab"><span class="id" title="notation">≠</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#bf4ebde00e5e9b74eb68426b182981ab"><span class="id" title="notation">:&gt;</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="var">hint_extern_solve_notin</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="var">_</span> <a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">notin</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a> <span class="id" title="var">_</span>) ⇒ <span class="id" title="var">hint_extern_solve_notin</span>.<br/>

<br/>
</div>

<div class="doc">
The next block of hints are occasionally useful when reasoning
    about finite sets.  In some instances, they obviate the need to
    use <span class="inlinecode"><span class="id" title="tactic">auto</span></span> <span class="inlinecode"><span class="id" title="keyword">with</span></span> <span class="inlinecode"><span class="id" title="tactic">set</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Resolve</span><br/>
&nbsp;&nbsp;<span class="id" title="var">AtomSetImpl.add_1</span> <span class="id" title="var">AtomSetImpl.add_2</span> <span class="id" title="var">AtomSetImpl.remove_1</span><br/>
&nbsp;&nbsp;<span class="id" title="var">AtomSetImpl.remove_2</span> <span class="id" title="var">AtomSetImpl.singleton_2</span> <span class="id" title="var">AtomSetImpl.union_2</span><br/>
&nbsp;&nbsp;<span class="id" title="var">AtomSetImpl.union_3</span> <span class="id" title="var">AtomSetImpl.inter_3</span> <span class="id" title="var">AtomSetImpl.diff_3</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab113"></a><h1 class="section">Decidable equality</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="Metalib.CoqEqDec.html#"><span class="id" title="library">Metalib.CoqEqDec</span></a>.<br/>

<br/>
</div>

<div class="doc">
We prefer that "==" refer to decidable equality at <span class="inlinecode"><a class="idref" href="Metalib.CoqMSetInterface.html#MakeListOrdering.eq"><span class="id" title="definition">eq</span></a></span>, as
    defined by the <span class="inlinecode"><a class="idref" href="Metalib.CoqEqDec.html#EqDec_eq"><span class="id" title="record">EqDec_eq</span></a></span> class from the CoqEqDec library. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="843a40d2a375f57bba4722a9e3cde6e8"><span class="id" title="notation">&quot;</span></a> x  == y " := (<a class="idref" href="Metalib.CoqEqDec.html#eq_dec"><span class="id" title="definition">eq_dec</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70) : <span class="id" title="var">coqeqdec_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">coqeqdec_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab114"></a><h1 class="section">Ott compatibility</h1>

<div class="paragraph"> </div>

 Implementation note (BEA): The following definitions make this
    library usable with the output of Ott's locally nameless backend.
    They may disappear or change as Ott changes. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="var"><span class="id" title="abbreviation">var</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#atom"><span class="id" title="abbreviation">atom</span></a> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="vars"><span class="id" title="abbreviation">vars</span></a> := <a class="idref" href="Metalib.MetatheoryAtom.html#atoms"><span class="id" title="abbreviation">atoms</span></a> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="eq_var"><span class="id" title="abbreviation">eq_var</span></a> := <a class="idref" href="Metalib.CoqEqDec.html#eq_dec"><span class="id" title="definition">eq_dec</span></a> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="82848982b0dae180809f3cb7c6487e4b"><span class="id" title="notation">&quot;</span></a>x  ===  y" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> <a class="idref" href="Metalib.CoqEqDec.html#843a40d2a375f57bba4722a9e3cde6e8"><span class="id" title="notation">==</span></a> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">coqeqdec_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="dcec358208377ee96804d20568734452"><span class="id" title="notation">&quot;</span></a>x \in s" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> <a class="idref" href="Metalib.Metatheory.html#cc4b473ff9ec85e2231c386241202ee8"><span class="id" title="notation">`</span></a><span class="id" title="keyword">in</span><a class="idref" href="Metalib.Metatheory.html#cc4b473ff9ec85e2231c386241202ee8"><span class="id" title="notation">`</span></a> <span class="id" title="var">s</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="31aff7cc3c70db0ca798935c949b4d12"><span class="id" title="notation">&quot;</span></a>x \notin s" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> <a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">notin</span></a><a class="idref" href="Metalib.Metatheory.html#54844931d0bc042c23f05adb9f972d99"><span class="id" title="notation">`</span></a> <span class="id" title="var">s</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="4d6dae03363ffe9be63da9d25488368c"><span class="id" title="notation">&quot;</span></a>s \u t" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">s</span> <a class="idref" href="Metalib.Metatheory.html#1e545c9ff2fca9b4a5741b8eeb20df3b"><span class="id" title="notation">`</span></a><a class="idref" href="Metalib.Metatheory.html#1e545c9ff2fca9b4a5741b8eeb20df3b"><span class="id" title="notation">union</span></a><a class="idref" href="Metalib.Metatheory.html#1e545c9ff2fca9b4a5741b8eeb20df3b"><span class="id" title="notation">`</span></a> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 65, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">set_sl_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">gather_vars_with</span> <span class="id" title="var">F</span> := <span class="id" title="var">gather_atoms_with</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">pick_fresh_gen</span> <span class="id" title="var">L</span> <span class="id" title="var">Y</span> := <span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">Y</span> <span class="id" title="keyword">for</span> <span class="id" title="var">L</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "auto" "*" := <span class="id" title="tactic">auto</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">apply_fresh_base</span> <span class="id" title="var">H</span> <span class="id" title="var">gather_vars</span> <span class="id" title="var">atom_name</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">L</span> := <span class="id" title="var">gather_vars</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">L</span> := <span class="id" title="var">beautify_fset</span> <span class="id" title="var">L</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" title="var">pick</span> <span class="id" title="tactic">fresh</span> <span class="id" title="var">x</span> <span class="id" title="var">excluding</span> <span class="id" title="var">L</span> <span class="id" title="var">and</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="union_map"><span class="id" title="definition">union_map</span></a> (<span class="id" title="var">A</span>:<span class="id" title="keyword">Set</span>) (<span class="id" title="var">f</span>:<a class="idref" href="Metalib.Metatheory.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="Metalib.Metatheory.html#vars"><span class="id" title="abbreviation">vars</span></a>) (<span class="id" title="var">l</span>:<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Metalib.Metatheory.html#A"><span class="id" title="variable">A</span></a>) :=<br/>
&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Lists.List.html#fold_right"><span class="id" title="definition">List.fold_right</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">t</span> <span class="id" title="var">acc</span> ⇒ <a class="idref" href="Metalib.Metatheory.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="Metalib.Metatheory.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Metalib.Metatheory.html#4d6dae03363ffe9be63da9d25488368c"><span class="id" title="notation">\</span></a><a class="idref" href="Metalib.Metatheory.html#4d6dae03363ffe9be63da9d25488368c"><span class="id" title="notation">u</span></a> <a class="idref" href="Metalib.Metatheory.html#acc"><span class="id" title="variable">acc</span></a>) <a class="idref" href="Metalib.Metatheory.html#2473ece9ad576f5f81f39e22ff1054b7"><span class="id" title="notation">{}</span></a>) <a class="idref" href="Metalib.Metatheory.html#l"><span class="id" title="variable">l</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>