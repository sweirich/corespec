%% This file uses the Ott tool to specify the grammar, typing and
%% evaluation rules for the implicit and explicit languages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar tmvar, x, y, f, m, n ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

metavar covar, c ::=
  {{ repr-locally-nameless }}
  {{ com coercion variables }}
  {{ lex alphanum }}

metavar datacon, K ::= {{ coq atom }}

metavar const, T ::= {{ coq atom }}
  {{ lex Alphanum }}

metavar tyfam, F ::= {{ coq atom }}
  {{ lex Alphanum }}

indexvar index, i ::=
  {{ tex \mathit{[[index]]} }} {{ com indices }} {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR

grammar

grade, psi {{ tex \ell }} :: 'q_' ::=   {{ coq grade }}
  | RTime                         :: M :: R  {{ tex { \color{black}{R} } }} {{ coq q_R }}
  | CTime                         :: M :: C  {{ tex { \color{black}{C} } }} {{ coq q_C }}
  | High                          :: M :: H  {{ tex { \color{black}{H} } }} {{ coq q_H }}
  | Middle                        :: M :: M  {{ tex { \color{black}{M} } }} {{ coq q_M }}
  | Low                           :: M :: L  {{ tex { \color{black}{L} } }} {{ coq q_L }}
  | top                           :: M :: Top {{ tex { \color{black}{\top} } }} {{ coq q_Top }}
  | bot                           :: M :: Bot {{ tex { \color{black}{\bot} } }} {{ coq q_Bot }}
  | psi1 \/ psi2                  :: M :: Join {{ tex [[psi1]] \vee [[psi2]] }} {{ coq (q_join [[psi1]] [[psi2]]) }}
  | psi1 /\ psi2                  :: M :: Meet {{ tex [[psi1]] \wedge [[psi2]] }} {{ coq (q_meet [[psi1]] [[psi2]]) }}
  | ( psi )                       :: M :: paren {{ tex [[ psi ]] }} 
                                                {{ coq ([[psi]]) }}


% relflag, rho {{ tex \rho }} :: '' ::= {{ com relevance flag }}
%    | +             ::   :: Rel
%    | -             ::   :: Irrel

constraint, phi {{ tex \phi }} :: '' ::= {{ com props }}
   | a ~ b : A        ::   :: Eq
     {{ tex [[a]] [[~]]_{[[A]]} [[b]] }}
   | ( phi )          :: S :: Paren
     {{ coq ([[phi]]) }}
   | phi { b / x }    :: S :: Subst
     {{ coq (open_constraint_wrt_tm [[x b]] [[phi]]) }}
   | | phi |          :: S :: Erase
     {{ coq (erase_constraint [[phi]]) }}
   | phi1 ==> phi2 :: :: Impl
%% TODO: think about adding this constraint
%% | phi1 ~ phi2       ::   :: CoIso


tm, a, b, v, w, A, B :: 'a_' ::= {{ com types and kinds }}
   | TYPE               ::   :: Star
     {{ tex \star }}
   | x                  ::   :: Var
   | \ psi x : A . b    ::   :: Abs (+ bind x in b +)
     {{ tex \mathrm{\lambda}[[x]]\!:^{[[psi]]}\![[A]].[[b]] }}
   | \ psi x . b        ::   :: UAbs (+ bind x in b +)
     {{ tex \mathrm{\lambda}[[x]]^{[[psi]]}.[[b]] }}
   | a psi b            ::   :: App
     {{ tex [[a]]\ [[b]]^{[[psi]]}  }}
   | F                  ::   :: Fam
   | T                  ::   :: Const
   | all x : psi A -> B ::   :: Pi (+ bind x in B +)
     {{ tex \mathrm{\Pi}[[x]]\!:^{[[psi]]}\![[A]][[->]][[B]] }}
   | a |> g             ::   :: Conv
   | all c : psi phi . B    ::   :: CPi (+ bind c in B +)
     {{ tex [[all]][[c]]\!:^{[[psi]]}\![[phi]].[[B]] }}
   | /\ psi c : phi . b     ::   :: CAbs (+ bind c in b +)
     {{ tex [[/\]][[c]]^{[[psi]]}\!:\!.[[b]] }}
   | /\ psi c  . b          ::   :: UCAbs (+ bind c in b +)
     {{ tex [[/\]][[c]]^{[[psi]]}.[[b]] }}
   | a [ g ]            ::   :: CApp
   % | []                 ::   :: Bullet

   %% currently unused but ready for extension
   | K                ::   :: DataCon
   | match a with brs ::   :: Case


   %% standard substitution, using open
   | a { b / x }      :: S :: Subst
     {{ coq (open_tm_wrt_tm [[x a]] [[b]]) }}

   %% this is a hack for when a substitution {x/x} is necessary for the
   %% locally nameless backend to generate the correct code, but we don't
   %% want this substitution to show in the tex output
   | a {{{ b / x }}}  :: S :: SecretSubst
     {{ coq (open_tm_wrt_tm [[x a]] [[b]]) }}
     {{ tex [[a]] }}

   | a { g / c }      :: S :: SubstC
     {{ coq (open_tm_wrt_co [[c a]] [[g]])  }}
   | a {{{ g / c }}}  :: S :: SecretSubstC
     {{ coq (open_tm_wrt_co [[c a]] [[g]])  }}
     {{ tex [[a]] }}


   | ( a )            :: S :: Paren
     {{ coq ([[a]]) }}
   %% Ott parsing precedence is hard
   | (# a #)          :: S :: SecretParen
     {{ coq [[a]] }} {{ tex [[a]] }}
     {{ com parsing precedence is hard }}

   |  | a |           :: S :: Erase   {{ coq (erase_tm [[a]]) }}

   %% abbreviations for examples
   | Int              :: S :: Int    {{ coq 0 }}
   | Bool             :: S :: Bool   {{ coq 0 }}
   | Nat              :: S :: Nat    {{ coq 0 }}
   | Vec              :: S :: Vec    {{ coq 0 }}
   | 0                :: S :: Zero   {{ coq 0 }}
   | Succ             :: S :: Succ   {{ coq 0 }} {{ tex \mathsf{S} }}
   | True             :: S :: True   {{ coq 0 }}
   | Fix              :: S :: Fix    {{ coq 0 }}
   | a -> b           :: S :: Arrow  {{ coq (a_Pi [[a]] [[b]]) }}
   | phi => A         :: S :: CArrow {{ coq (a_CPi [[phi]] [[A]]) }}
   | a b              :: S :: RelApp
     {{ coq (a_App [[a]] Rel [[b]]) }}
   | \ x . a          :: S :: RelUAbs
     {{ coq (a_UAbs Rel [[a]]) }}
     {{ tex \lambda [[x]].[[a]] }}
   | \ x : A . a      :: S :: RelAbs
     {{ coq (a_Abs Rel [[A]] [[a]]) }}
     {{ tex \lambda [[x]]\!:\![[A]].[[a]] }}
   | all x : A -> B   :: S :: RelPi
     {{ coq (a_Pi  Rel [[A]] [[B]]) }}

%% Currently unused
brs :: 'br_' ::=    {{ com case branches }}
   | none             ::   :: None
   | K => a ; brs     ::   :: One
   | brs { a / x }    :: S :: Subst  {{ coq (open_brs_wrt_tm [[x brs]] [[a]]) }}
   | brs { g / c }    :: S :: SubstC {{ coq (open_brs_wrt_co [[c brs]] [[g]]) }}
   | ( brs )          :: S :: Paren  {{ coq ([[brs]]) }}

co, g {{ tex \gamma }} :: 'g_' ::= {{ com explicit coercions }}
   | o                    ::   :: Triv
   | c                    ::   :: Var
   | red a b              ::   :: Beta

   | refl a               ::   :: Refl
   | refl2 a b g          ::   :: Refl2
     {{ tex ([[a]]\mathrel{|\!\!=\!\!|}_{[[g]]}[[b]]) }}
   | sym g                ::   :: Sym
   | g1 ; g2              ::   :: Trans

   | all x : psi g1 -> g2 ::   :: PiCong (+ bind x in g2 +)
     {{ tex \mathrm{\Pi}^[[x]]^[[psi]]\!:\![[g1]].[[g2]] }}

   | \ psi x : g1 . g2    ::   :: AbsCong (+ bind x in g2 +)
     {{ tex \mathrm{\lambda}[[x]]^[[psi]]\!:\![[g1]].[[g2]] }}

   | g1 psi g2            ::   :: AppCong
     {{ tex [[g1]]\ [[g2]]^[[psi]] }}

   | piFst g              ::   :: PiFst
   | cpiFst g             ::   :: CPiFst
   | isoSnd g            ::   :: IsoSnd
   | g1 @ g2              ::   :: PiSnd

   | all c : g1 . g3      ::   :: CPiCong (+ bind c in g3 +)
     {{ tex [[all]][[c]]\!:\![[g1]].[[g3]] }}

   | \ psi c : g1 . g3 @ g4   ::   :: CAbsCong (+ bind c in g3 +)
     {{ tex \mathrm{\lambda}[[c]]\!:\![[g1]].[[g3]][[@]][[g4]] }}

   | g ( g1 , g2 )        ::   :: CAppCong
   | g @ ( g1 , g2 )      ::   :: CPiSnd
     {{ tex [[g]] [[@]] ([[g1]] \sim [[g2]]) }}
   | g1 |> g2             ::   :: Cast
   | g1 ~ A  g2           ::   :: EqCong
     {{ tex [[g1]] [[~]]_{[[A]]} [[g2]] }}
   | conv phi1 phi2 g     ::   :: IsoConv
     {{ tex [[conv]]\ [[phi1]]\sim_[[g]] [[phi2]] }}

   | eta a                ::   :: Eta
   | left g g'            ::   :: Left
   | right g g'           ::   :: Right

   | ( g )                :: S :: Paren   {{ coq ([[g]]) }}
   | (# g #)              :: S :: SecretParen
     {{ coq [[g]] }} {{ tex [[g]] }}
   | g { a / x }          :: S :: TSubst
     {{ coq open_co_wrt_tm [[x g]] [[a]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

substitutions
  single a x   :: tm_subst_tm
  single g x   :: co_subst_tm
  single a c   :: tm_subst_co
  single g c   :: co_subst_co
  single brs x :: brs_subst_tm
  single brs c :: brs_subst_co

freevars
  a x   :: fv_tm_tm
  g x   :: fv_co_tm
  a c   :: fv_tm_co
  g c   :: fv_co_co
  brs x :: fv_tm_brs
  brs c :: fv_co_brs

parsing
  a_Abs right a_App
  a_UAbs right a_App
  a_Abs <= a_RelApp
  a_UAbs <= a_RelApp
  a_App left a_App
  a_RelApp left a_App
  a_App left a_RelApp
  a_RelApp left a_RelApp
  a_CApp left a_App
  a_App left a_CApp
  a_CApp left a_RelApp
  a_RelApp left a_CApp

  a_Arrow right a_Arrow
  a_App right a_Arrow
  a_RelApp right a_Arrow
  a_Pi right a_Arrow
  a_CPi right a_Arrow

  a_Arrow <= a_Pi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  This part is not handled by LNgen

grammar

sig_sort :: '' ::= {{ com signature classifier }}
   | Cs A            ::    :: Cs
   | Ax a A          ::    :: Ax

sort :: '' ::= {{ com binding classifier }}
   | Tm A             ::   :: Tm
   | Co phi           ::   :: Co


grammar

context, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com contexts }}
                                          {{ coq list ( atom * (grade * sort) ) }}
   | empty           ::    :: Empty   {{ coq nil }}

   | G , x : psi A   ::    :: ConsTm  {{ coq (([[x]]~ ([[psi]], Tm [[A]])) ++ [[G]]) }} 
                                      {{ tex [[x]]\! :^{[[psi]]}\![[A]] }}
   | G , c : psi phi ::    :: ConsCo  {{ coq (([[c]]~ ([[psi]], Co [[phi]])) ++ [[G]]) }}
                                      {{ tex [[c]]\! :^{[[psi]]}\![[phi]] }}
   | G { b / x }     :: M  :: SubstA  {{ coq (open_context_wrt_tm [[x G]][[b]] }}
   | G { g / c }     :: M  :: SubstG  {{ coq (open_context_wrt_co [[c G]][[g]]  }}
   | G ++ G'         :: M  :: Append  {{ coq ([[G]] ++ [[G']]) }}
     {{ tex [[G]], [[G']] }}
   | | G |           :: M  :: Erase   {{ coq (erase_context [[G]]) }}
   | ( G )           :: M  :: Paren   {{ coq ([[G]]) }}
   | (# G #)         :: M  :: SecretParen {{ coq [[G]] }} {{ tex [[G]] }}
   | psi /\ G        :: M  :: Meet_l      {{ coq (meet_ctx_l [[psi]] [[G]]) }}
                                          {{ tex [[psi]] \wedge [[G]] }}

econtext, P {{ tex \Phi }} :: 'ectx_' ::= {{ com erased contexts }}
                                          {{ coq list ( atom * grade ) }}
  | empty             ::  M   :: Empty    {{ coq nil }}
  | G |               ::  M   :: Erased   {{ tex | [[ G ]] | }}
                                          {{ coq (labels [[G]]) }}
  | x : psi           ::  M   :: OneTm    {{ tex [[x]] \! : [[ psi ]] }}
                                          {{ coq ([[x]]~[[psi]])}}
  | c : psi           ::  M   :: OneCo    {{ tex [[c]] \! : [[ psi ]] }}
                                          {{ coq ([[c]]~[[psi]])}}
  | P , x : psi       ::  M   :: ConsTm   {{ coq ([[x]]~ [[psi]]) ++ [[P]] }}
  | P , c : psi       ::  M   :: ConsCo   {{ coq ([[c]]~ [[psi]]) ++ [[P]] }}
  | P ++ P'           ::  M   :: Append   {{ tex [[P]] , [[P']] }} {{ coq ([[P']]++[[P]]) }}
  | (# P #)           ::  M   :: SecretParen {{ tex [[ P ]] }} {{ coq [[P]] }}
  | ( P )             ::  M   :: Paren {{ tex ([[ P ]]) }} {{ coq ([[P]]) }}


% available_props, D {{ tex \Delta }} :: 'D_' ::= {{ coq atoms }} {{ coq-universe Type }}
%    | emptyD          ::    :: Empty   {{ coq AtomSetImpl.empty }} {{ tex \varnothing }}
%    | D , c           ::    :: ConsCo  {{ coq (singleton [[c]] \u [[D]]) }}
%    | dom G           :: M  :: DomG    {{ coq (dom [[G]]) }} {{ tex \widetilde {[[G]]} }}
%    | ( D )           :: M  :: Paren   {{ coq ([[D]]) }}

sig, S {{ tex \Sigma }} :: 'sig_' ::= {{ com signatures }} {{ coq list (atom * sig_sort) }}
   | emptyS         ::    :: Empty       {{ coq nil }}
     {{ tex \varnothing }}
   | S , T : A      ::    :: ConsCs      {{ coq (([[T]]~ Cs[[A]])++[[S]]) }}
     {{ tex [[S]] \cup \{[[T]] : [[A]]\} }}
   | S , F ~ a : A  ::    :: ConsAx      {{ coq (([[F]]~ Ax[[a]][[A]])++[[S]]) }}
     {{ tex [[S]] \cup \{[[F]]\sim[[a]] : [[A]]\} }}
   | toplevel       :: M  :: Toplevel
     {{ coq toplevel }}
     {{ tex \Sigma_0 }}
   | an_toplevel    :: M  :: AnToplevel
     {{ coq an_toplevel }}
     {{ tex \Sigma_1 }}
   | | S |          :: M  :: Erase  {{ coq (erase_sig [[S]]) }}



substitutions
  single G x :: ctx_subst_tm
  single G c :: ctx_subst_co

freevars
  G x :: fv_ctx_tm
  G c :: fv_ctx_co




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Terminals  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

terminals :: 'terminals_' ::=
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | -->               ::   :: step          {{ tex \longrightarrow }}
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall     {{ tex \forall }}
  | in                ::   :: in         {{ tex \in }}
  | notin             ::   :: notin      {{ tex \not\in }}
  | <=                ::   :: leq      {{ tex \leq }}
  | =>                ::   :: infer      {{ tex \Rightarrow }}
  | =>*               ::   :: minfer      {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow      {{ tex \to }}
  | /\                ::   :: ilam       {{ tex \mathrm{\Lambda} }}   % Swag
  | <-|               ::   :: mapsfrom   {{ tex \mapsfrom }}
  | []                ::   :: box        {{ tex \Box }}
  | |-                ::   :: entails    {{ tex \vdash }}
  | -|                ::   :: produces   {{ tex \dashv }}
  | |=                ::   :: hs_entails {{ tex \vDash }}
  | |==               ::   :: hs_entaill {{ tex \vDash }}
  | /=                ::   :: neq        {{ tex \neq }}
  | |>                ::   :: cast       {{ tex \triangleright }}
  | ok                ::   :: ok         {{ tex \ \mathsf{ok} }}
  | _                 ::   :: blank      {{ tex \_ }}
  | ~>                ::   :: produce    {{ tex \leadsto }}
  | ~>*               ::   :: multistep  {{ tex \leadsto^{\ast} }}
  | ~>h               ::   :: steph      {{ tex \leadsto }}
  | empty             ::   :: empty      {{ tex \varnothing }}
  | hole              ::   :: hole       {{ tex \circ }}
  | fv                ::   :: fv         {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom        {{ tex \mathsf{dom} }}
  | ~                 ::   :: twiddle    {{ tex \sim }}
  | ~~                ::   :: compatible {{ tex \asymp }}
  | '|'               ::   :: bar        {{ tex | }}
  | o                 ::   :: bullet     {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | |=>|              ::   :: erasesto   {{ tex \mathrel{|\Rightarrow|} }}
  | |-=               ::   :: turneq     {{ tex \vdash_{=} }}
  | refl2             ::   :: refl2      {{ tex \mathbf{refl_2}  }}
  | ++                ::   :: concat     {{ tex \mathop{++} }}
  | ==>               ::   :: impl       {{ tex \implies }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | x : psi in P               ::   :: inP
    {{ coq binds [[x]] [[psi]] [[P]] }}

  | x : psi A in G               ::   :: inG
    {{ coq binds [[x]] ([[psi]], (Tm [[A]])) [[G]] }}
    {{ tex [[x]]\! :^{[[psi]]}\![[A]] \in [[G]] }}

  | c : psi phi  in G         ::   :: inGP
    {{ coq binds [[c]] ([[psi]], (Co [[phi]])) [[G]] }}
    {{ tex [[c]]\! :^{[[psi]]}\![[phi]] \in [[G]] }}

  | T : A in S             ::   :: inGF
    {{ coq binds [[T]] (Cs [[A]]) [[S]] }}

  | F ~ a : A in S             ::   :: inGFam
    {{ coq binds [[F]] (Ax [[a]][[A]]) [[S]] }}

  | K : T G in S               ::   :: inSD
    {{ coq binds [[K]] ([[T]],[[G]]) [[S]] }}

  % | x in D                   ::   :: availx
  %   {{ coq AtomSetImpl.In [[x]] [[D]] }}
  % | c in D                   ::   :: avail
  %   {{ coq AtomSetImpl.In [[c]] [[D]] }}
  | c not relevant in g      ::   :: notrelevant
    {{ coq [[c]] \notin (fv_relevant [[g]]) }}
  | x notin fv a             ::   :: fresh
    {{ coq [[x]] \notin fv_tm_tm_tm [[a]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
  | c notin dom G            ::   :: notInGc
    {{ coq ~ AtomSetImpl.In [[c]] (dom [[G]]) }}
  | x notin dom P            ::   :: notInPx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[P]]) }}
  | c notin dom P            ::   :: notInPc
    {{ coq ~ AtomSetImpl.In [[c]] (dom [[P]]) }}
  | T notin dom S            ::   :: notInST
    {{ coq ~ AtomSetImpl.In [[T]] (dom [[S]]) }}
  | F notin dom S            ::   :: notInSF
    {{ coq ~ AtomSetImpl.In [[F]] (dom [[S]]) }}
  | a = b                    ::   :: equal
    {{ coq ([[a]] = [[b]]) }}
  |  phi1 =  phi2       ::   :: erasedphi
    {{ coq ([[phi1]] = [[phi2]]) }}
  | G1 = G2                  ::   :: equalctx
    {{ coq ([[G1]] = [[G2]]) }}
  | g1 = g2                  ::   :: equalco
    {{ coq ([[g1]] = [[g2]]) }}
  | not formula              ::   :: not
    {{ coq not ([[formula]]) }}
  | formula1 /\ formula2     ::   :: and
    {{ coq [[formula1]] /\ [[formula2]] }}
  | formula1 \/ formula2     ::   :: or
    {{ coq [[formula1]] \/ [[formula2]] }}
  | formula1 implies formula2     ::   :: implies
    {{ coq [[formula1]] -> [[formula2]] }}
  | ( formula )              ::   :: Paren
    {{ coq ([[formula]]) }}
  | [ formula ]              ::   :: Regular
    {{ coq ([[formula]]) }}
    {{ tex \suppress{[[formula]]} }}
  | c : (a : A ~ b : B) in G ::   :: Alt
    {{ coq True }}
  | nolc A                   ::   :: NoLC
    {{ com suppress lc hypothesis generated by Ott }}
    {{ coq True }}
	 {{ tex      }}
  | psi1 <= psi2              ::   :: subrho
    {{ coq ([[psi1]] <= [[psi2]]) }}
  | psi1 < psi2               ::   :: ltrho
    {{ coq ([[psi1]] < [[psi2]]) }}
  | uniq P                   ::   :: uniqP
    {{ coq uniq [[P]] }} {{ tex }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Coq Definitions necessary to specify the semantics

embed {{ coq
Definition labels : context -> econtext :=
  map (fun '(u , s) => u).

Definition join_ctx_l (psi : grade) : context -> context :=    
  map (fun '(g, A) => (psi * g, A)).

Definition join_ctx_r (psi : grade) : context -> context :=
  map (fun '(g, A) => (g * psi, A)).

Definition meet_ctx_l (psi : grade) : context -> context :=
  map (fun '(g, A) => (psi + g, A)).

Definition meet_ctx_r (psi : grade) : context -> context :=
  map (fun '(g, A) => (g + psi, A)).

Fixpoint erase_tm (a : tm) : tm :=
   match a with
   | a_Star    => a_Star
   | a_Var_b n => a_Var_b n
   | a_Var_f x => a_Var_f x
   | a_Abs rho A b => a_UAbs rho (erase_tm b)
   | a_UAbs rho b => a_UAbs rho (erase_tm b)
   | a_App a Rel b => a_App (erase_tm a) Rel (erase_tm b)
   | a_App a Irrel b => a_App (erase_tm a) Irrel a_Bullet
   | a_Const T => a_Const T
   | a_Fam F => a_Fam F
   | a_Pi rho A B => a_Pi rho (erase_tm A) (erase_tm B)
   | a_Conv a _ => erase_tm a
   | a_CPi phi B => a_CPi (erase_constraint phi) (erase_tm B)
   | a_CAbs phi b => a_UCAbs (erase_tm b)
   | a_UCAbs b => a_UCAbs (erase_tm b)
   | a_CApp a g => a_CApp (erase_tm a) g_Triv
   | a_DataCon K => a_Star  (* a_DataCon K *)
   | a_Case a brs => a_Star (* a_Case (erase_tm a) (erase_brs brs) *)
   | a_Bullet => a_Bullet
   end
with erase_brs (x : brs) : brs :=
   match x with
   | br_None => br_None
   | br_One k a y => br_One k (erase_tm a) (erase_brs y)
   end
with erase_constraint (phi : constraint) : constraint :=
   match phi with
   | Eq A B A1 => Eq (erase_tm A) (erase_tm B) (erase_tm A1)
   | Impl phi1 phi2 => Impl (erase_constraint phi1) (erase_constraint phi2)
   end.

Definition erase_sort s :=
 match s with
 | Tm a => Tm (erase_tm a)
 | Co p => Co (erase_constraint p)
end.


Definition erase_csort s :=
 match s with
 | Cs a   => Cs (erase_tm a)
 | Ax a A => Ax (erase_tm a) (erase_tm A)
end.

Definition erase_context G := map (fun (psi, s) => (psi, erase_sort s)) G.
Definition erase_sig S := map erase_csort S.

(* -------------- A specific signature with Fix ------------ *)
Definition Fix : atom.
  pick fresh F.
  exact F.
Qed.

Definition FixDef : tm :=
  (a_Abs Irrel a_Star
         (a_Abs Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
                (a_App (a_Var_b 0) Rel
                       (a_App (a_App (a_Fam Fix) Irrel (a_Var_b 1)) Rel (a_Var_b 0))))).

Definition FixTy : tm :=
  a_Pi Irrel a_Star
       (a_Pi Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
             (a_Var_b 1)).


Definition an_toplevel : sig := Fix ~ Ax FixDef FixTy.

Definition toplevel : sig := erase_sig an_toplevel.

}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% "Syntactic" definitions


defns
JValue :: '' ::=

defn
CoercedValue A ::   :: CoercedValue :: ''
{{ com Values with at most one coercion at the top }}
by

Value a
----------------- :: CV
CoercedValue a

Value a
---------------------- :: CC
CoercedValue (a |> g)

defn
Value A  ::   :: Value    :: 'Value_'
{{ com values }}
{{ tex \suppress{\mathsf{Value}\ [[A]]} }}
by

------- :: Star
Value TYPE

-------------------------- :: Pi
Value all x : psi A -> B

-------------------- :: CPi
Value all c : psi phi. B

--------------------- :: Abs
Value \ psi x:A. a

--------------------- :: UAbs
Value \ psi x. a

% Value a
% --------------------- :: UAbsIrrel
% Value \ - x. a

% CoercedValue a
% -------------------- :: AbsIrrel
% Value \ - x:A. a

--------------------- :: CAbs
Value /\psi c:phi.a

--------------------- :: UCAbs
Value /\psi c .a


defn
ValueType A ::   :: value_type :: 'value_type_'
{{ com Types with head forms (erased language) }}
by

------- :: Star
ValueType TYPE

-------------------------- :: Pi
ValueType all x : psi A -> B

-------------------- :: CPi
ValueType all c : psi phi. B


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Definitions for consistency proof

defns
   Jconsistent :: '' ::=

defn
   consistent a b ::  :: consistent :: 'consistent_a_'
   {{ com (erased) types do not differ in their heads }}
by

---------------------- :: Star
consistent TYPE TYPE

------------------------ :: Pi
consistent (all x1: psi1 A1 -> B1) (all x2: psi2 A2 -> B2)

------------------------ :: CPi
consistent (all c1:psi1 phi1. A1) (all c2 :psi2 phi2. A2)

			  not ValueType b
---------------------- :: Step_R
consistent a b

not ValueType a
---------------------- :: Step_L
consistent a b

% defns
% JChk :: '' ::=

% defn
% rho => check x in A ::    :: RhoCheck :: 'Rho_'
% {{ tex ([[rho]] = +) \vee ([[x]]\not\in\mathsf{fv}\; [[A]]) }}
% {{ com irrelevant argument check }}
% by

% nolc A
% -------------------- :: Rel
% + => check x in A

% x notin fv A
% -------------------- :: IrrRel
% - => check x in A

defns
  Jerased :: '' ::=

defn
  erased_constraint phi ::  :: erased_constraint :: 'erased_c_'
by

erased_tm a
erased_tm b
erased_tm A
--------- :: Eq
erased_constraint a ~ b : A


erased_constraint phi1
erased_constraint phi2
------------------------ :: Impl
erased_constraint phi1 ==> phi2

defn
  erased_tm a ::  :: erased_tm :: 'erased_a_'
by

% --------- :: Bullet
% erased_tm []

------------  :: Star
erased_tm TYPE

-------- :: Var
erased_tm x

erased_tm a
-------------------- :: Abs
erased_tm (\psi x.a)


erased_tm a
erased_tm b
----------------- :: App
erased_tm (a psi b)

% erased_tm a
% ----------------- :: AppIrrel
% erased_tm (a - [])

erased_tm A
erased_tm B
------------------------- :: Pi
erased_tm (all x: psi A -> B)

erased_constraint phi
erased_tm B
---------------------------------- :: CPi
erased_tm (all c:psi phi . B)

erased_tm b
--------------- :: CAbs
erased_tm (/\psi c. b)

erased_tm a
--------------- :: CApp
erased_tm (a [o])

-------- :: Fam
erased_tm F



% defns
%  JRhoEta :: '' ::=

% defn
% rho => eta x in b  ::    :: RhoEta :: 'RhoEta_'
% by
%
% ------------------- :: Rel
% + => eta x in x
%
% ------------------  :: Irrel
% - => eta x in []


defns
  Jpar :: '' ::=


defn
P |- psi psi0 phi1 => phi2 :: :: CParProp :: 'CParProp_'
{{ tex [[P]] \vDash_{[[psi]]}^{[[psi0]]} [[phi1]] [[=>]] [[phi2]] }}
{{ com guarded parallel reduction for props (implicit language) }}
by

psi0 <= psi
P |- psi phi1 => phi2
----------------------- :: Leq
P |- psi psi0 phi1 => phi2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |- psi psi0 phi1 => phi2


defn
P |- psi psi0 a => b :: :: CPar :: 'CPar_'
{{ tex [[P]] \vDash_{[[psi]]}^{[[psi0]]} [[a]] [[=>]] [[b]] }}
{{ com guarded parallel reduction (implicit language) }}
by

psi0 <= psi
P |- psi a1 => a2
----------------------- :: Leq
P |- psi psi0 a1 => a2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |- psi psi0 a1 => a2


defn
P |- psi phi1 => phi2 :: :: ParProp :: 'ParProp_'
{{ tex [[P]] \vDash_{[[psi]]} [[phi1]] [[=>]] [[phi2]] }}
{{ com parallel reduction for props (implicit language) }}
by

P |- psi a => a'
P |- psi b => b'
P |- psi A => A'
----------------------- :: Eq
P |- psi a ~ b : A => a' ~ b' : A'

P |- psi phi1 => phi1'
P |- psi phi2 => phi2'
----------------------- :: Impl
P |- psi phi1 ==> phi2 => phi1' ==> phi2'


defn
P |- psi a => b ::  :: Par :: 'Par_'
{{ tex [[P]] \vDash_{[[psi]]} [[a]] [[=>]] [[b]] }}
{{ com parallel reduction (implicit language) }}
by

P |= psi a
----------------------- :: Refl
P |- psi a => a


P |- psi a => (\psi x.a')
P |- psi psi0 b => b'
---------------------------- :: Beta
P |- psi a psi0 b => a' { b' / x }

% G |- a => (\- x.a')
% ---------------------------- :: BetaIrrel
% G |- a - [] => a' { [] / x }

P |- psi a => a'
P |- psi psi0 b => b'
-------------------------- :: App
P |- psi a psi0 b => a' psi0 b'

% YL: Do we need to keep this?
% G |- a => a'
% -------------------------- :: AppIrrel
% G |- a - [] => a' - []


% What to do with the psi here?
P |- psi a => (/\psi0 c .a')
----------------------- :: CBeta
P |- psi a [o] => a' { o / c }

P |- psi a => a'
----------------------- :: CApp
P |- psi a [o] => a' [o]

P |- psi a => a'
-------------------------------- :: Abs
P |- psi \ psi0 x. a => \ psi0 x. a'

P |- psi A => A'
P , x:psi |- psi B => B'
-------------------------------------------- :: Pi
P |- psi all x: psi0 A -> B => all x:psi0 A' -> B'

P |- psi a => a'
--------------------------- :: CAbs
P |- psi /\ psi0 c . a => /\ psi0 c . a'

P |- psi a => a'
P, c:psi |- psi phi => phi'
----------------------------------------- :: CPi
P |- psi all c: psi0 phi. a => all c: psi0 phi'. a'

% NOTE: toplevel is assumed to be locally closed
F ~ a : A in toplevel
-------------------------------- :: Axiom
P |- psi F => a

P |- psi b => b'
a = b psi0 x
----------------------------- :: Eta
P |- psi \psi0 x. a => b'


% G |- b => b'
% a = b - []
% ----------------------------- :: EtaIrrel
% G |- \- x. a => b'

P |- psi b => b'
a = b [o]
----------------------------- :: EtaC
P |- psi /\top c. a => b'


defns
  Jmultipar :: '' ::=

defn
P |- psi a =>* b ::   :: multipar :: 'mp_'
{{ tex [[P]] [[|-]]_{[[psi]]} [[a]] [[=>*]] [[b]] }}
{{ com multistep parallel reduction }}
by

------------------ :: refl
P |- psi a =>* a

P |- psi a => b
P |- psi b =>* a'
--------------------- :: step
P |- psi a =>* a'

defn
P |- psi phi =>* phi' ::   :: multipar_prop :: 'mpprop_'
{{ tex [[P]] [[|-]]_{[[psi]]} [[phi]] [[=>*]] [[phi']] }}
{{ com multistep parallel reduction for constraints }}
by

------------------ :: refl
P |- psi phi =>* phi

P |- psi phi1 => phi2
P |- psi phi2 =>* phi3
--------------------- :: step
P |- psi phi1 =>* phi3


% defns
%   Jjoins :: '' ::=

% defn
% G |- a <=> b ::   :: joins :: ''
% {{ tex [[|-]] [[a]] [[<=>]] [[b]] }}
% {{ com parallel reduction to a common term }}
% by

% erased_tm a1
% erased_tm a2
% erased_tm b
% G |- a1 =>* b
% G |- a2 =>* b
% ------------------------ :: join
% G |- a1 <=> a2

% defn
% G |- phi1 <=> phi2 ::   :: joinsProp :: 'Prop_'
% {{ tex [[|-]] [[phi1]] [[<=>]] [[phi2]] }}
% {{ com parallel reduction to a common constraint }}
% by

% G |- phi1 =>* phi
% G |- phi2 =>* phi
% ------------------------ :: join
% G |- phi1 <=> phi2




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implicit (or erased) language reductions

defns
 Jbeta :: '' ::=

defn
|= a > b  ::     :: Beta :: 'Beta_'
{{ com primitive reductions on erased terms }}
by

------------------------------------ :: AppAbs
|= (\psi x.v) psi b > v { b / x }

% Value (\- x. v)
% ------------------------------------ :: AppAbsIrrel
% |= (\- x.v) - [] > v { [] / x }


------------------------------- :: CAppCAbs
|= (/\ psi c .a') [o] > a' { o / c }


F ~ a : A in toplevel
-------------------------------- :: Axiom
|= F > a


defn
 |= a ~> b ::   :: reduction_in_one :: 'E_'
{{ com single-step head reduction for implicit language }}
by

% |= a ~> a'
% -------------------------  :: AbsTerm
% |= \- x.a ~> \- x.a'

|= a ~> a'
-------------------------  :: AppLeft
|= a psi b ~> a' psi b

% |= a ~> a'
% -------------------------  :: AppLeftIrrel
% |= a - [] ~> a' - []

|= a  ~> a'
-----------------------------   :: CAppLeft
|= a [o]  ~> a' [o]


----------------------------------  :: AppAbs
|= (\psi x.v) psi a ~> v { a / x}

% Value (\- x. v)
% ----------------------------------  :: AppAbsIrrel
% |= (\- x.v) - [] ~> v { [] / x}

--------------------------------  :: CAppCAbs
|= (/\psi c .b) [o] ~> b { o / c}

F ~ a : A in toplevel
-------------------- :: Axiom
|= F ~> a


defn

|= a ~>* b ::  :: reduction :: ''
{{ com multistep reduction }}
by

------------------- :: Equal
|= a ~>* a

|= a ~> b
|= b ~>* a'
------------------- :: Step
|= a ~>* a'

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implicit (or erased) language type system

defns
Jett :: '' ::=


defn
G |= psi phi ok ::    :: PropWff :: 'E_'
{{ tex [[G]] \vDash_{[[psi]]} [[phi]] ok }}
{{ com Prop wellformedness }}
by

G |= psi a : A
G |= psi b : A
[ G |= psi A : TYPE ]
---------------------------  :: WffEq
G |= psi a ~ b : A  ok

G |= psi phi1 ok
G |= psi phi2 ok
---------------------------  :: WffImpl
G |= psi phi1 ==> phi2 ok


defn

G |= psi a : A ::   :: Typing :: 'E_'
{{ tex [[G]] \vDash [[a]]:^{[[psi]]} [[A]] }}
{{ com typing }}
by

|= G
------------  :: Star
G |= psi TYPE : TYPE

|= G
psi0 <= psi
x: psi0 A in G
------------------ :: Var
G |= psi x : A

%% 2nd premise is redundant, but convenient for IH
G, x:psi A |= psi B : TYPE
[ G |= psi A : TYPE ]
------------------------------------ :: Pi
G |= psi all x:psi0 A -> B : TYPE

G, x:psi0 \/ psi A |= psi a : B
% YL: psi or CTime?
[ CTime /\ G |= CTime A : TYPE ]
---------------------------------- :: Abs
G |= psi \ psi0 x . a : all x:psi0 A -> B


% Split into 2
G |= psi b : all x : psi0 A -> B
G |= psi0 \/ psi a : A
psi0 <= CTime
------------------------------------- :: App
G |= psi b psi0 a : B { a / x }

G |= psi b : all x : psi0 A -> B
CTime /\ G |= CTime a : A
CTime < psi0
% not psi0 <= CTime
% it's okay to use psi0 here
% we know that psi <= C holds all the time.
% the only way to go higher is to have psi0 > C?
------------------------------------- :: AppIrrel
G |= psi b psi0 a : B { a / x }


% YL: replaced by AppIrrel?
% G |= b : all x : psi A -> B
% G |= a : A
% ------------------------------------- :: IApp
% G |= b - [] : B { a / x }


G |= psi a : A
CTime /\ G |= CTime A ~ B : TYPE
[ CTime /\ G |= CTime B : TYPE ]
----------------------------- :: Conv
G |= psi a : B

G, c : psi phi |= psi B : TYPE
[ G |= psi phi ok ]
-------------------------------- :: CPi
G |= psi all c:psi0 phi. B : TYPE

G, c: psi0 \/ psi phi |= psi a : B
% Is this okay?
[ CTime /\ G |= CTime phi ok ]
------------------------------------------------- :: CAbs
G |= psi /\ psi0 c . a : all c:psi0 phi. B

% YL: by default, we have [o] as T. need to extend to CAppRel, CAppIrrel in the future
G |= psi a1 : all c : top phi . B1
CTime /\ G |= CTime phi
------------------------------------------- :: CApp
G |= psi a1 [ o ] : B1 { o / c }


% this isn't right: add a label to top-level expressions?
CTime <= psi
|= G
F ~ a : A in toplevel
[ empty |= CTime A : TYPE ]
------------------ :: Fam
G |= psi F : A


defn
G |= psi phi1 == phi2  ::    :: Iso :: 'E_'
{{ tex [[G]] \vDash [[phi1]] \equiv ^{[[psi]]} [[phi2]] }}
{{ com prop equality }}
by

G |= psi A1 ~ A2 : A
G |= psi B1 ~ B2 : A
---------------------------------------- :: PropCong
G |= psi A1 ~ B1 : A == A2 ~ B2 : A

% phi1 == phi2 ok should imply phi1,phi2 : Prop
% at the same grade
G |= psi A ~ B : TYPE
G |= psi A1 ~ A2 : A ok
G |= psi A1 ~ A2 : B ok
----------------------------------------- :: IsoConv
G |= psi A1 ~ A2 : A == A1 ~ A2 : B

G |= psi all c:psi0 phi1. B1 ~ all c:psi0 phi2. B2 : TYPE
------------------------------------------------- :: CPiFst
G |= psi phi1 == phi2

G |= psi phi1 == phi2
G |= psi phi3 == phi4
-------------------------------------- :: ImplCong
G |= psi phi1 ==> phi3 == phi2 ==> phi4


defn
 G |= psi psi0 a ~ b : A :: :: CDefEq :: 'CDefEq_' {{ com Definitional Equality }}
 {{ tex [[ G ]] \vdash [[ a ]] \equiv_{[[ psi ]]} [[ b ]]  }}
by
   psi0 <= psi
   G |= psi a ~ b : A
  --------------------- :: Leq 
   G |= psi psi0 a ~ b : A


   not (psi0 <= psi)
   |= G
   psi0 <= CTime
   G |= psi0 \/ psi a : A
   G |= psi0 \/ psi b : A
  --------------------- :: Nleq 
   G |= psi psi0 a ~ b : A

   not (psi0 <= psi)
   |= G
   CTime < psi0
   CTime /\ G |= CTime a : A
   CTime /\ G |= CTime b : A
  --------------------- :: NleqIrrel
   G |= psi psi0 a ~ b : A




defn

G |= psi phi ::     :: DefEq :: 'E_'
{{ tex [[G]] \vDash_{[[psi]]} [[phi]] }}
{{ com definitional equality }}
by

% labeled well-formedness judgment?
|= G
psi0 <= psi
c : psi0 phi in G
-------------------- :: Assn
G |= psi phi

G |= psi a : A
-------------------- :: Refl
G |= psi a ~ a : A

G |= psi b ~ a : A
-------------------- :: Sym
G |= psi a ~ b : A

G |= psi a ~ a1 : A
G |= psi a1 ~ b : A
------------------------------------- :: Trans
G |= psi a ~ b : A


G |= psi a1 : B
% YL: is CTime the right label?
[G |= psi a2 : B]
|= a1 > a2
--------------------------------  :: Beta
G |= psi a1 ~ a2 : B

%% Rules related to functions

G |=  psi A1 ~ A2 : TYPE
G, x: psi A1 |= psi B1 ~ B2 : TYPE
%% this needed by weakening IH
[G |= psi A1 : TYPE]
%% these two needed by regularity
[G |= psi all x: psi0 A1 -> B1 : TYPE]
[G |= psi all x: psi0 A2 -> B2 : TYPE]
---------------------------------------------------------- :: PiCong
G |= psi (all x: psi0 A1 -> B1) ~ (all x: psi0 A2 -> B2) : TYPE


G, x: psi0 \/ psi A1 |= psi b1 ~ b2 : B
[ CTime /\ G |= CTime A1 : TYPE ]
-------------------------------------------------------------- :: AbsCong
G |= psi (\psi0 x. b1) ~ (\psi0 x. b2) : all x: psi0 A1 -> B

% YL: AppIrrel is handled in the guarded version of defeq
G |= psi a1 ~ b1 : all x: psi0 A -> B
G |= psi psi0 a2 ~ b2 : A
-------------------------------------- :: AppCong
G |= psi a1 psi0 a2 ~ b1 psi0 b2 : ( B { a2 / x } )


G |= psi all x: psi0 A1 -> B1 ~ all x: psi0 A2 -> B2 : TYPE
------------------------------------------------- :: PiFst
G |=  psi A1 ~ A2 : TYPE

G |= psi all x: psi0 A1 -> B1 ~ all x: psi0 A2 -> B2 : TYPE
G |= psi a1 ~ a2 : A1
------------------------------------------- :: PiSnd
G |=  psi B1 {a1 /x}  ~ B2 {a2/x} : TYPE

%% Rules related to Coercion Abstraction

% YL: I think it's okay to use psi instead of CTime
% joinability still covers propositions
G |= psi phi1 == phi2
% not a typo! 
G, c: psi phi1 |= psi A ~ B : TYPE
[G |= psi phi1 ok]
[G |= psi all c:psi0 phi1. A : TYPE]
[G |= psi all c:psi0 phi2. B : TYPE]
--------------------------------------------------------- :: CPiCong
G |= psi all c:psi0 phi1. A  ~ all c:psi0 phi2. B : TYPE

G, c: psi0 \/ psi phi1 |= psi a ~ b : B
[ CTime /\ G |= CTime phi1 ok ]
------------------------------------------------------------ :: CAbsCong
G |= psi (/\psi0 c . a) ~ (/\ psi0 c . b) : all c:psi0 phi1. B

% YL: hardwired psi0 to top
G |= psi a1 ~ b1 : all c: top phi. B
CTime /\ G |= CTime phi
-------------------------------------- :: CAppCong
G |= psi a1 [o] ~ b1 [o] : B { o / c }

G |= psi all c: psi0 phi1. B1 ~ all c:psi0 phi2. B2 : TYPE
CTime /\ G |= CTime phi1
CTime /\ G |= CTime phi2
---------------------------------------------- :: CPiSnd
G |=  psi B1 { o / c} ~ B2 { o / c } : TYPE

%% Other rules

G |= psi phi1
G |= psi phi1 == phi2
-------------------------------------- :: Cast
G |= psi phi2

G |= psi a ~ b : A
CTime /\ G |= psi A ~ B : TYPE
-------------------------------------- :: EqConv
G |= psi a ~ b : B

G |= psi a ~ b : A == a' ~ b' : A'
-------------------------------------- :: IsoSnd
G |= psi A ~ A' : TYPE

G |= psi b : all x:psi0 A -> B
a = b psi0 x
------------------------------------------ :: EtaRel
G |= psi \psi0 x. a ~ b : all x: psi0 A -> B

% G |= b : all - x:A -> B
% a = b - []
% ------------------------------------------ :: EtaIrrel
% G |= \- x. a ~ b : all - x:A -> B

G |= psi b : all c:top phi. B
a = b [o]
------------------------------------------ :: EtaC
G |= psi /\top c. a ~ b : all c:top phi. B

G |= psi phi1 ==> phi2
G |= psi phi1
--------------------------------------------------- :: ImplApp
G |= psi phi2


G , c : CTime phi1 |= psi phi2
--------------------------------------------------- :: ImplAbs
G |= psi phi1 ==> phi2



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% We can also add many more rules about "injectivity"
%% to this language including:

% G ; D |=  (/\c . a) == (/\ c . b) : all c:phi1. B
% ------------------------------------------------------------ :: CAbsFst
% G, c: phi1 ; D |= a == b : B

% G ; D |=  (\ rho x. b1) == (\ rho x. b2) : all rho x:A1 -> B
% -------------------------------------------------------------- :: AbsFst
% G, x:A1 ; D |= b1 == b2 : B

% G |= a1 : all - x:A -> B
% G |= b1 : all - x:A -> B
% G ; D |= a1 - [] == b1 - [] : B { a / x }
% ------------------------------------------ :: IAppFst
% G ; D |= a1 == b1 : all - x:A -> B


% G |= a1 : all c:a ~ b : A. B
% G |= b1 : all c:a ~ b : A. B
% G ; D |= a1 [o] == b1 [o] : B { o / c }
% -------------------------------------- :: CAppFst
% G ; D |= a1 == b1 : all c:a ~ b : A. B


% YL: should I generalize this to |= psi G?
% and use |= top G in all leaf derivations?
% not sure what that would buy us
defn
|= G ::    :: Ctx  :: 'E_'
{{ com context wellformedness }}
by

---------- :: Empty
|= empty

|= G
CTime /\ G |= CTime A : TYPE
x notin dom G
--------------------- :: ConsTm
|= G, x : psi A

|= G
CTime /\ G |= CTime phi ok
c notin dom G
-------------------- :: ConsCo
|= G, c: psi phi



defns 
  Jsub :: '' ::=

defn 
  P1 <= P2  ::   :: P_sub :: 'P_' {{ com Context sub }}
by

----------------- :: Empty
  empty <= empty

  psi1 <= psi2
  P1 <= P2
  x notin dom P1
  x notin dom P2
---------------------------------- :: Cons
  P1 , x : psi1 <= P2 , x : psi2
        

defns 
  Wsub :: '' ::=

defn 
  G1 <= G2  ::   :: ctx_sub :: 'CS_' {{ com Context sub }}
by

----------------- :: Empty
  empty <= empty

  psi1 <= psi2
  G1 <= G2
  x notin dom G1
  x notin dom G2
  % why do we need nolc here?
  nolc A
------------------------------------ :: ConsTm
  G1 , x:psi1 A <= G2 , x:psi2 A

  psi1 <= psi2
  G1 <= G2
  c notin dom G1
  c notin dom G2
  % YL:why do we need nolc here?
  % nolc A
------------------------------------ :: ConsCo
  G1 , c:psi1 phi <= G2 , c:psi2 phi


defns 
   JGrade :: '' ::= 

defn
 P |= psi phi :: :: CoGrade :: 'CoG_' {{ com Guarded Grade for coercions }}
 {{ tex [[ P ]] \vDash_{[[psi]]} [[ phi ]]   }}
by

P |= psi a
P |= psi b
P |= psi A
--------------------- :: Eq
P |= psi a ~ b : A


P |= psi phi1
P |= psi phi2
--------------------- :: Impl
P |= psi phi1 ==> phi2



defn
 P |= psi psi0 a :: :: CGrade :: 'CG_' {{ com Guarded Grade }}
 {{ tex [[ P ]] \vdash_{[[ psi ]]}^{[[psi0]]} [[ a ]]  }}

by
   psi0 <= psi
   P |= psi a
  --------------------- :: Leq 
   P |= psi psi0 a

   not (psi0 <= psi)
   uniq P
  --------------------- :: Nleq 
   P |= psi psi0 a




defn 
  P |= psi a ::   :: Grade :: 'G_' {{ com Observable variables are bounded by their grades }}
{{ tex [[P]] \vdash_{[[psi]]} [[a]] }}

by

uniq P
x : psi0 in P
psi0 <= psi
------------------ :: Var
P |= psi x

uniq P
----------------- :: Type
P |= psi TYPE

P |= psi A
P, x:psi |= psi B
------------------ :: Pi
P |= psi all x : psi0 A -> B

P, x :psi0 |= psi b
------------------------------------------ :: Abs
P |= psi \ psi0 x . b 

P |= psi b 
P |= psi psi0 a 
------------------------------------------- :: App
P |= psi b psi0 a 

P |= psi phi
P , c : psi |= psi B
------------------------------------------------- :: CPi
P |= psi all c :psi0 phi . B

P , c : psi0 |= psi b
------------------------------------- :: CAbs
P |= psi /\ psi0 c . b

P |= psi b
-------------------------------- :: CApp
P |= psi b [ o ]


% TODO: figure out how GEq is defined
% [ G |= psi phi ok ]
% P, c : psi |= psi B : TYPE
% -------------------------------- :: CPi
% G |= psi all c:psi0 phi. B : TYPE

defns
   JGEq :: '' ::=

% TODO: add CoCEq in the future

defn
 P |= psi phi1 ~~ phi2 :: :: CoGEq :: 'CoGEq_' {{ com Syntactic Graded Equality for coercions }}
 {{ tex [[ P ]] \vDash [[ phi1 ]] \sim_{[[ psi ]]} [[ phi2 ]]  }}
by

P |= psi a ~~ a'
P |= psi b ~~ b'
P |= psi A ~~ A'
--------------------- :: Eq
P |= psi a ~ b : A ~~ a' ~ b' : A'


P |= psi phi1 ~~ phi2
P |= psi phi3 ~~ phi4
--------------------- :: Impl
P |= psi phi1 ==> phi3 ~~ phi2 ==> phi4


defn 
P |= psi psi0 a ~~ b ::  :: CEq :: 'CEq_' {{ com Syntactic equality at [[psi]] is guarded by [[psi0]] }}
 {{ tex [[ P ]] \vDash^{[[psi0]]}_{[[psi]]} [[ a ]] \sim [[ b ]]  }}

by

psi0 <= psi
P |= psi a1 ~~ a2
---------------------- :: Leq
P |= psi psi0 a1 ~~ a2

not (psi0 <= psi)
uniq P
-------------------------------- :: Nleq
P |= psi psi0 a1 ~~ a2

defn
 P |= psi a ~~ b :: :: GEq :: 'GEq_' {{ com Syntactic Graded Equality }}
 {{ tex [[ P ]] \vDash [[ a ]] \sim_{[[ psi ]]} [[ b ]]  }}

by
uniq P
x : psi0 in P 
psi0 <= psi
------------------------------------------ :: Var
P |= psi x ~~ x

uniq P
---------------------------- :: Type
P |= psi TYPE ~~ TYPE

P |= psi A1 ~~ A2
P , x : psi |= psi B1 ~~ B2
------------------------------------------------- :: Pi
P |= psi all x :psi0 A1 -> B1 ~~ all x :psi0 A2 -> B2

P , x : psi0 |= psi b1 ~~ b2
------------------------------------- :: Abs
P |= psi \ psi0 x  . b1 ~~ \ psi0 x . b2


P |= psi b1 ~~ b2
P |= psi psi0 a1 ~~ a2
-------------------------------- :: App
P |= psi b1 psi0 a1 ~~ b2 psi0 a2

P |= psi phi1 ~~ phi2
P , c : psi |= psi B1 ~~ B2
------------------------------------------------- :: CPi
P |= psi all c :psi0 phi1 . B1 ~~ all c :psi0 phi2 . B2

P , c : psi0 |= psi b1 ~~ b2
------------------------------------- :: CAbs
P |= psi /\ psi0 c . b1 ~~ /\ psi0 c . b2

P |= psi b1 ~~ b2
-------------------------------- :: CApp
P |= psi b1 [ o ] ~~ b2 [ o ]




defns

Jsig :: '' ::=

defn
|= S ::    :: Sig :: 'Sig_'
{{ com signature wellformedness }}
by

------------ :: Empty
|= emptyS

% is CTime the right level?
|= S
empty |= CTime A : TYPE
empty |= CTime a : A
F notin dom S
---------------- :: ConsAx
|= S, F ~ a : A










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Annotated language semantics
%

% TODO: add grades to DC

defns
Jann :: '' ::=

defn
G |- psi phi ok ::   :: AnnPropWff :: 'An_'
{{ com prop wellformedness }}
by

G |- psi a : A
G |- psi b : B
|A| = |B|
------------------------- :: Wff
G |- psi a ~ b : A  ok

defn
G |- psi a : A ::  :: AnnTyping :: 'An_'
{{ com typing }}
by

|- G
------------  :: Star
G |- psi TYPE : TYPE

|- G
x : psi0 A in G
psi0 <= psi
----------- :: Var
G |- psi x : A

G, x: psi A |- psi B : TYPE
[ G |- psi A : TYPE ]
------------------------------------ :: Pi
G |- psi all x: psi0 A -> B : TYPE

[ CTime /\ G |- CTime A : TYPE ]
G, x:psi0 \/ psi A |- psi a : B
---------------------------------- :: Abs
G |- psi \ psi0 x : A. a : all x: psi0 A -> B

G |- psi b : all x:psi0 A -> B
G |- psi0 \/ psi a : A
psi0 <= CTime
------------------------------------- :: App
G |- psi b psi0 a : B { a / x }

G |- psi b : all x:psi0 A -> B
CTime /\ G |- CTime a : A
CTime < psi0
------------------------------------- :: AppIrrel
G |- psi b psi0 a : B { a / x }


G |- psi a : A
CTime /\ G |- CTime g : A ~ B
CTime /\ G |- CTime B : TYPE
----------------------------- :: Conv
G |- psi a |> g : B

[ G |- psi phi ok ]
G, c : psi phi |- psi B : TYPE
-------------------------------- :: CPi
G |- psi all c:psi0 phi. B : TYPE

[ CTime /\ G |- CTime phi ok ]
G, c : psi0 \/ psi phi |- psi a : B
------------------------------------------------- :: CAbs
G |- psi /\ psi0 c: phi. a : all c: psi0 phi. B

G |- psi a1 : all c : top a ~ b : A1. B
CTime /\ G |- CTime g : a ~ b
------------------------------------- :: CApp
G |- psi a1 [ g ] : B { g / c }

|- G
CTime <= psi
F ~ a : A in an_toplevel
[ empty |- CTime A : TYPE ]
----------------------- :: Fam
G |- psi F : A

defn
G |- psi g : phi1 == phi2 ::  :: AnnIso :: 'An_'
{{ tex [[G]][[|-]] [[g]] :_{[[psi]]} [[phi1]] \sim [[phi2]] }}
{{ com coercion between props }}
by

G |- psi g1 : A1 ~ A2
G |- psi g2 : B1 ~ B2
G |- psi A1 ~ B1 : A ok
G |- psi A2 ~ B2 : A ok
---------------------------------------------------------- :: PropCong
G |- psi (g1 ~A g2) : (A1 ~ B1 : A) == (A2 ~ B2 : A)

G |- psi g : all c:psi0 phi1. A2 ~ all c:psi0 phi2. B2
--------------------------------------- :: CPiFst
G |- psi cpiFst g : phi1 == phi2

G |- psi g : phi1 == phi2
---------------------------- :: IsoSym
G |- psi sym g : phi2 == phi1

G |- psi g : A ~ B
CTime /\ G |- CTime a1 ~ a2 : A ok
CTime /\ G |- CTime a1' ~ a2' : B ok
|a1| = |a1'|
|a2| = |a2'|
-------------------------------------- :: IsoConv
G |- psi conv (a1 ~ a2 : A) (a1' ~ a2' : B) g : (a1 ~ a2 : A) == (a1' ~ a2' : B)


defn
G |- psi psi0 g : A ~ B :: :: AnnDefCEq :: 'An_'
{{ com guarded coercion between types }}
by
% TODO


defn
G |- psi g : A ~ B ::  :: AnnDefEq :: 'An_'
{{ com coercion between types }}
by

|- G
psi0 <= psi
c: psi0 a ~ b : A in G
------------------- :: Assn
G |- psi c : a ~ b

G |- psi a : A
----------------------------- :: Refl
G |- psi refl a : a ~ a

G |- psi a : A
G |- psi b : B
|a| = |b|
CTime /\ G |- CTime g : A ~ B
----------------------------- :: EraseEq
G |- psi refl2 a b g : a ~ b


G |- psi b : B
G |- psi a : A
[ CTime /\ G |- CTime g1 : B ~ A ]
G |- psi g : b ~ a
-------------------------- :: Sym
G |- psi sym g : a ~ b

G |- psi g1 : a ~ a1
G |- psi g2 : a1 ~ b
[ G |- psi a : A ]
[ G |- psi a1 : A1 ]
[ CTime /\ G |- CTime g3 : A ~ A1 ]
------------------------------------- :: Trans
G |- psi (g1 ; g2) : a ~ b

G |- psi a1 : B0
G |- psi a2 : B1
|B0| = |B1|
|= |a1| > |a2|
--------------------------------  :: Beta
G |- psi red a1 a2 : a1 ~ a2


%% Note: need to include {x/x} to emphasize that x is free in B2 for
%% the locally nameless backend.
G |- psi g1 : A1 ~ A2
G, x : psi A1 |- psi g2 : B1 ~ (# B2 {{{ x / x }}} #)
B3 = B2 { x |> sym g1 / x }
G |- psi all x:psi0 A1 -> B1 : TYPE
G |- psi all x:psi0 A2 -> B3 : TYPE
G |- psi (all x:psi0 A1 -> B2) : TYPE
---------------------------------------------------------- :: PiCong
G |- psi all x:psi0 g1 -> g2 : (all x:psi0 A1 -> B1) ~ (all x:psi0 A2 -> B3)

CTime /\ G |- CTime g1 : A1 ~ A2
G, x : psi0 A1 |- psi g2 : b1 ~ (# b2 {{{x / x}}} #)
b3 = b2 { x |> sym g1 / x }
[ CTime /\ G |- CTime A1 : TYPE ]
CTime /\ G |- CTime A2 : TYPE
% rho => check x in | b1 |
% rho => check x in | b3 |
[G |- psi \ psi0 x :A1. b2 : B]
------------------------------------------------------------------ :: AbsCong
G |- psi (\psi0 x:g1. g2) : (\psi0 x: A1. b1) ~ (\psi0 x: A2. b3)
 % TODO: fix gamma



% really want heterogenous equality here.
%% NOTE: we know that G |- g3 : A ~ B  must hold (b/c reg), but adding it as
%% an extra assumption for the erasure proof.
G |- psi g1 : a1 ~ b1
G |- psi psi0 g2 : a2 ~ b2
G |- psi a1 psi0 a2 : A
G |- psi b1 psi0 b2 : B
[ CTime /\ G |- CTime g3 : A ~ B ]
-------------------------------------- :: AppCong
G |- psi g1 psi0 g2 : a1 psi0 a2 ~ b1 psi0 b2


G |- psi g : all x:psi0 A1 -> B1 ~ all x:psi0 A2 -> B2
--------------------------------------- :: PiFst
G |- psi piFst g : A1 ~ A2

G |- psi g1 : all x:psi0 A1 -> B1  ~ all x:psi0 A2 -> B2
G |- psi g2 : a1 ~ a2
G |- psi a1 : A1
G |- psi a2 : A2
--------------------------------------- :: PiSnd
G |- psi g1 @ g2 : (# B1 {a1 /x} #) ~ (# B2 {a2/x} #)


G |- psi g1 : phi1 == phi2
G, c:psi phi1 |- psi g3 : B1 ~ (# B2 {{{c/c}}} #)
B3 = B2 { c |> sym g1 / c }
G |- psi all c: psi0 phi1 . B1 : TYPE
[G |- psi all c:psi0 phi2 . B3 : TYPE]
G |- psi all c:psi0 phi1 . B2 : TYPE
----------------------------------------------------- :: CPiCong
G |- psi (all c: g1. g3) : (all c:psi0 phi1. B1) ~ (all c:psi0 phi2. B3)


G |- psi g1 : phi1 == phi2
G, c:psi0 \/ psi phi1 |- psi g3 : a1 ~ (# a2{{{c/c}}} #)
a3 = a2 { c |> sym g1 / c }
%% To know that the two types are equal, we need to know
%% that the range types can be shown identical without using
%% the assumption c:phi1. This is a stronger property than
%% regularity implies.
G |- psi (/\ psi0 c:phi1. a1) : all c:psi0 phi1. B1
G |- psi (/\ psi0 c:phi2. a3) : all c:psi0 phi2. B2
G |- psi (/\ psi0 c:phi1. a2) : B
CTime /\ G |- psi g4 : all c:psi0 phi1. B1 ~ all c:psi0 phi2. B2
---------------------------------------------------------------- :: CAbsCong
G |- psi (\ psi0 c: g1. g3 @ g4) : (/\ psi0 c:phi1. a1) ~ (/\ psi0 c:phi2. a3)


G |- psi g1 : a1 ~ b1
CTime /\ G |- CTime g2 : a2 ~ b2
CTime /\ G |- CTime g3 : a3 ~ b3
G |- psi a1 [g2] : A
G |- psi b1 [g3] : B
[ CTime /\ G |- CTime g4 : A ~ B ]
-------------------------------------- :: CAppCong
G |- psi g1 (g2, g3) : a1 [ g2 ]  ~ b1 [ g3 ]


G |- psi g1 : (all c1:psi0 a~a':A. B1) ~ (all c2:psi0 b~b':B. B2)
CTime /\ G |- CTime g2 : a~a'
CTime /\ G |- CTime g3 : b~b'
-------------------------------------------------- :: CPiSnd
G |- psi g1 @ (g2, g3) : B1 { g2 / c1 } ~ B2 { g3 / c2 }


G |- psi g1 : a~a'
G |- psi g2 : a~a' :A == b~b' : B
--------------------------------------- :: Cast
G |- psi g1 |> g2 : b~b'


G |- psi g : (a~a' : A) == (b~b' : B)
---------------------------------- :: IsoSnd
G |- psi isoSnd g : A ~ B


G |- psi b : all x:psi0 A -> B
a = b psi0 x
--------------------------------------------------- :: Eta
G |- psi eta b : (\psi0 x:A. a) ~ b


G |- psi b : all c:psi0 phi. B
a = b [c]
--------------------------------------------------- :: EtaC
G |- psi eta b : (/\ psi0 c:phi. a) ~ b


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defn
|- G ::      :: AnnCtx :: 'An_'
{{ com context wellformedness }}
by


---------- :: Empty
|- empty

|- G
CTime /\ G |- CTime A : TYPE
x notin dom G
--------------------- :: ConsTm
|- G, x : psi0 A

|- G
CTime /\ G |- CTime phi ok
c notin dom G
-------------------- :: ConsCo
|- G, c: psi0 phi

defn
|- S ::    :: AnnSig :: 'An_Sig_'
{{ com signature wellformedness }}
by

------------ :: Empty
|- emptyS

|- S
empty |- CTime A : TYPE
empty |- CTime a : A
F notin dom S
---------------- :: ConsAx
|- S, F ~ a  : A


defns
  Jred :: '' ::=

defn
G |- a ~>h b ::   :: head_reduction :: 'An_'
{{ com single-step, weak head reduction to values for annotated language }}
% NOTE: this reduction needs a context for the the
% two push rules. We need to read the coercion proofs
% to know what type annotations to use after the push.
by

G |- a ~>h a'
-------------------------  :: AppLeft
G |- a psi0 b ~>h a' psi0 b

Value (\psi0 x:A.w)
-----------------------------------------  :: AppAbs
G |- (\psi0 x:A.w) psi0 a ~>h w { a / x}


G |- a  ~>h a'
-----------------------------   :: CAppLeft
G |- a [g]  ~>h a' [g]


------------------------------------  :: CAppCAbs
G |- (/\psi0 c:phi.b) [g] ~>h b { g / c}

% no longer needed?
% G |- A : TYPE
% G, x : A |- b ~>h b'
% ------------------------------------------- :: AbsTerm
% G |- (\- x:A. b) ~>h (\- x:A. b')


F ~ a : A in an_toplevel
------------------------- :: Axiom
G |- F ~>h a


G |- a ~>h a'
---------------------------- :: ConvTerm
 G |- a |> g ~>h a' |> g


Value v
------------------------------------- :: Combine
G |- (v |> g1) |> g2 ~>h v |> (g1 ; g2)

% Not used (or needed)

%   G ; dom G |- g : all rho x1:A1 -> B1 ~ all rho x2:A2 -> B2
%   a1 = a { x2 |> sym (piFst g) / x1 }
%   g2 = g @ refl2 (# x2 |> sym (piFst g) #) x2 (# piFst g #)
% ------------------------------------------------------------------------- :: Push
%   G |- ( (\rho x1:A1.a) |> g ) rho b ~>h (\rho x2:A2. (a1 |> g2)) rho b

%   G ; dom G |- g : all c1:phi1. A1 ~ all c2:phi2. A2
%   a1 = a { c2 |> sym (cpiFst g)  / c1 }
%   g2 = g @ (c2 |> sym (cpiFst g), c2)
% ------------------------------------------------------------------ :: CPush
%   G |- ( (/\c1:phi1.a) |> g ) [g1] ~>h (/\c2:phi2. (a1 |> g2)) [g1]



Value v
CTime /\ G |- psi g : all x1: psi0 A1 -> B1 ~ all x2: psi0 A2 -> B2
b' = b |> sym (piFst g)
g' = g @ refl2 b' b (piFst g)
---------------------------------------------------------- :: Push
G |- (v |> g) psi0 b ~>h (v psi0 b') |> g'


Value v
CTime /\ G |- psi g : all c1:psi0 phi1. A1 ~ all c2:psi0 phi2. A2
g1' = g1 |> sym (cpiFst g)
g' = g @ ( g1' , g1 )
-------------------------------------------------------- :: CPush
G |- (v |> g) [g1] ~>h (v [g1']) |> g'
