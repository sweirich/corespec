%% This file uses the Ott tool to specify the grammar, typing and
%% evaluation rules for the implicit and explicit languages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%__ Metavariables __%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

metavar tmvar, x, y, f, m, n ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

metavar covar, c ::=
  {{ repr-locally-nameless }}
  {{ com coercion variables }}
  {{ lex alphanum }}

metavar datacon, K ::=
  {{ coq atom }}

metavar const, T, F, Age ::=
  {{ coq atom }}
  {{ lex Alphanum }}


indexvar index, i ::=
  {{ tex \mathit{[[index]]} }}
  {{ com indices }}
  {{ coq nat }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%__ Grammar __%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

relflag, rho {{ tex \rho }} :: '' ::= {{ com relevance flag }}
  | +             ::   :: Rel
  | -             ::   :: Irrel
  | app_rho nu    :: S :: RhoApp {{ coq app_rho [[nu]] }}
  | ( rho )       :: S :: RhoParen {{ coq ([[rho]]) }}


appflag, nu {{ tex \nu }} :: '' ::= {{ com applicative flag }}
  | R   ::  :: Role
  | rho ::  :: Rho


role, R :: '' ::= {{ com Role }}
  | Nom         ::   :: Nom
  | Rep         ::   :: Rep
  | min R1 R2   :: S :: Min
  | param R1 R2 :: S :: Param
  | app_role nu :: S :: App {{ coq app_role [[nu]] }}
  | ( R )       :: S :: RParen


constraint, phi {{ tex \phi }} :: '' ::= {{ com props }}
  | a ~ b : A / R    ::   :: Eq
  | ( phi )          :: S :: Paren
  | phi { b / x }    :: S :: Subst
  | | phi |          :: S :: Erase
  | a ~ b / R        :: S :: EqNT



tm, a, b, p, v, w, A, B, C :: 'a_' ::= {{ com types and kinds }}
  | TYPE                 ::   :: Star

  | x                    ::   :: Var
  | \ rho x : A . b      ::   :: Abs   (+ bind x in b +)
  | \ rho x . b          ::   :: UAbs  (+ bind x in b +)
  | a nu b               ::   :: App
  | all rho x : A -> B   ::   :: Pi    (+ bind x in B +)

  | /\ c : phi . b       ::   :: CAbs  (+ bind c in b +)
  | /\ c  . b            ::   :: UCAbs (+ bind c in b +)
  | a [ g ]              ::   :: CApp
  | all c : phi . B      ::   :: CPi   (+ bind c in B +)

  | a |> R g             ::   :: Conv

  | F                    ::   :: Fam

  | []                   ::   :: Bullet

  | case R a of F => b1 | _ => b2 ::   :: Pattern

  %% currently unused but ready for extension
  | K                    ::   :: DataCon
  | match a with brs     ::   :: Case

	%% change the role in an annotated term
  | sub R a              ::    :: Sub

  %% standard substitution, using open
  | a { b / x }          :: S :: Subst
  | a { g / c }          :: S :: SubstC

  %% Actual standard substitution
  | a {` b / x `}        :: S :: StdTmSubst
  | a {` g / c `}          :: S :: StdCoSubst

  %% this is a hack for when a substitution {x/x} is necessary for the
  %% locally nameless backend to generate the correct code, but we don't
  %% want this substitution to show in the tex output
  | a {{{ b / x }}}      :: S :: SecretSubst
  | a {{{ g / c }}}      :: S :: SecretSubstC


  | ( a )                :: S :: Paren
  %% Ott parsing precedence is hard
  | (# a #)              :: S :: SecretParen

  |  | a | R             :: S :: Erase

  %% abbreviations for examples
  | Int                  :: S :: Int
  | Bool                 :: S :: Bool
  | Nat                  :: S :: Nat
  | Vec                  :: S :: Vec
  | 0                    :: S :: Zero
  | Succ                 :: S :: Succ
  | True                 :: S :: True
  | Fix                  :: S :: Fix
  | a -> b               :: S :: Arrow
  | phi => A             :: S :: CArrow
  | a b                  :: S :: RelApp
  | \ x . a              :: S :: RelUAbs
  | \ x : A . a          :: S :: RelAbs
  | all x : A -> B       :: S :: RelPi
  | if phi then a else b :: S :: If



%% Currently unused
brs :: 'br_' ::=    {{ com case branches }}
   | none             ::   :: None
   | K => a ; brs     ::   :: One
   | brs { a / x }    :: S :: Subst  {{ coq (open_brs_wrt_tm [[x brs]] [[a]]) }}
   | brs { g / c }    :: S :: SubstC {{ coq (open_brs_wrt_co [[c brs]] [[g]]) }}
   | ( brs )          :: S :: Paren  {{ coq ([[brs]]) }}



co, g {{ tex \gamma }} :: 'g_' ::= {{ com explicit coercions }}
   | o                      ::   :: Triv
   | c                      ::   :: Var
   | red a b                ::   :: Beta

   | refl a                 ::   :: Refl
   | refl2 a b g            ::   :: Refl2

   | sym g                  ::   :: Sym
   | g1 ; g2                ::   :: Trans

   | sub g                  ::   :: Sub

   | all rho R x : g1 -> g2 ::   :: PiCong   (+ bind x in g2 +)

   | \ rho R x : g1 . g2    ::   :: AbsCong  (+ bind x in g2 +)

   | g1 rho R g2            ::   :: AppCong

   | piFst g                ::   :: PiFst
   | cpiFst g               ::   :: CPiFst
   | isoSnd g               ::   :: IsoSnd
   | g1 @ g2                ::   :: PiSnd

   | all c : g1 . g3        ::   :: CPiCong  (+ bind c in g3 +)

   | \ c : g1 . g3 @ g4     ::   :: CAbsCong (+ bind c in g3 +)

   | g ( g1 , g2 )          ::   :: CAppCong
   | g @ ( g1 , g2 )        ::   :: CPiSnd
   | g1 |> R g2             ::   :: Cast
   | g1 ~ A  g2             ::   :: EqCong
   | conv phi1 phi2 g       ::   :: IsoConv

   | eta a                  ::   :: Eta
   | left g g'              ::   :: Left
   | right g g'             ::   :: Right

   | ( g )                  :: S :: Paren
   | (# g #)                :: S :: SecretParen
   | g { a / x }            :: S :: TSubst

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

substitutions
  single a x   :: tm_subst_tm
  single g x   :: co_subst_tm
  single a c   :: tm_subst_co
  single g c   :: co_subst_co
  single brs x :: brs_subst_tm
  single brs c :: brs_subst_co

freevars
  a x   :: fv_tm_tm
  g x   :: fv_co_tm
  a c   :: fv_tm_co
  g c   :: fv_co_co
  brs x :: fv_tm_brs
  brs c :: fv_co_brs

parsing
  a_Abs right a_App
  a_UAbs right a_App
  a_Abs <= a_RelApp
  a_UAbs <= a_RelApp
  a_App left a_App
  a_RelApp left a_App
  a_App left a_RelApp
  a_RelApp left a_RelApp
  a_CApp left a_App
  a_App left a_CApp
  a_CApp left a_RelApp
  a_RelApp left a_CApp

  a_Arrow right a_Arrow
  a_App right a_Arrow
  a_RelApp right a_Arrow
  a_Pi right a_Arrow
  a_CPi right a_Arrow

  a_Arrow <= a_Pi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%__ /!\  This part is not handled by LNgen /!\ __%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

role_context, W {{ tex \Omega }} :: 'rctx_' ::= {{ com role_contexts }}
                                          {{ coq list ( atom * role ) }}
   | empty           ::    :: Empty   {{ coq nil }}
   | x : R           ::    :: Tm      {{ coq ([[x]] ~ [[R]]) }}
   | W , x : R       ::    :: ConsTm  {{ coq (([[x]] ~ [[R]]) ++ [[W]]) }}
   | W ++ W'         :: M  :: Append  {{ coq ([[W]] ++ [[W']]) }}
   {{tex [[W]],[[W']]}}
   | var_pat p       :: M  :: Pat {{ coq (var_pat([[p]])) }}
   | ( W )           :: M  :: Paren   {{ coq ([[W]]) }}
   | (# W #)         :: M  :: SecretParen {{ coq [[W]] }} {{ tex [[W]] }}

roles, Rs :: '' ::= {{ coq list role }} 
   | nilR       ::  :: nilR {{ coq nil }}
   | R , Rs     ::  :: consR {{ coq ([[R]]::[[Rs]]) }}
   | range W   :: S :: rangeR {{ coq (range([[W]])) }}

sig_sort :: '' ::= {{ com signature classifier }}
   | A @ Rs            ::    :: Cs
   | p ~ a : A / R @ Rs    ::    :: Ax
     {{ tex \, [[p]] \sim [[a]] : [[A]] / [[R]] @ [[Rs]] }}

sort :: '' ::= {{ com binding classifier }}
   | Tm A             ::   :: Tm
   | Co phi           ::   :: Co

context, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com contexts }}
                                          {{ coq list ( atom * sort ) }}
   | empty           ::    :: Empty   {{ coq nil }}

   | G , x : A       ::    :: ConsTm  {{ coq (([[x]]~ Tm [[A]]) ++ [[G]]) }}
   | G , c : phi     ::    :: ConsCo  {{ coq (([[c]]~ Co [[phi]]) ++ [[G]]) }}

   | G { b / x }     :: M  :: SubstA  {{ coq (open_context_wrt_tm [[x G]][[b]] }}
   | G { g / c }     :: M  :: SubstG  {{ coq (open_context_wrt_co [[c G]][[g]]  }}
   | G ++ G'         :: M  :: Append  {{ coq ([[G]] ++ [[G']]) }}
     {{ tex [[G]], [[G']] }}
   | | G |           :: M  :: Erase   {{ coq (erase_context [[G]]) }}
   | ( G )           :: M  :: Paren   {{ coq ([[G]]) }}
   | (# G #)         :: M  :: SecretParen {{ coq [[G]] }} {{ tex [[G]] }}

sig, S {{ tex \Sigma }} :: 'sig_' ::=
    {{ com signatures }}
    {{ coq list (atom * sig_sort) }}
  | emptyS         ::    :: Empty
    {{ coq nil }}
     {{ tex \varnothing }}
  | S , F : sig_sort ::    :: Cons
   {{ coq (([[F]]~[[sig_sort]])++[[S]]) }}
   {{ tex [[S]] \cup \{[[F]] : [[sig_sort]]\} }}
  | toplevel       :: M  :: Toplevel
     {{ coq toplevel }}
     {{ tex \Sigma_0 }}
  | an_toplevel    :: M  :: AnToplevel
     {{ coq an_toplevel }}
     {{ tex \Sigma_1 }}
  | | S |          :: M  :: Erase
   {{ coq (erase_sig [[S]]) }}


available_props, D {{ tex \Delta }} :: 'D_' ::= {{ coq atoms }} {{ coq-universe Type }}
   | emptyD          ::    :: Empty   {{ coq AtomSetImpl.empty }} {{ tex \varnothing }}
   | D , x           ::    :: ConsVar {{ coq (singleton [[x]] \u [[D]]) }}
   | D , c           ::    :: ConsCo  {{ coq (singleton [[c]] \u [[D]]) }}
   | fv a            :: M  :: FreeVars {{ coq (fv_tm_tm_tm [[a]]) }}
   | D , D'          :: M  :: Append  {{ coq ([[D]] `union` [[D']]) }} {{ tex [[D]], [[D']] }}
   | dom G           :: M  :: DomG    {{ coq (dom [[G]]) }} {{ tex \widetilde {[[G]]} }}
   | dom W           :: M  :: DomW    {{ coq (dom [[W]]) }} {{ tex \widetilde {[[W]]} }}
   | ( D )           :: M  :: Paren   {{ coq ([[D]]) }}


Nat, N {{ tex \mathbb{N} }} :: 'N_' ::= {{ coq nat }}
   | length a :: S :: Pattern_length {{ coq (pattern_length [[a]]) }} {{ tex | [[a]] | }}


substitutions
  single G x :: ctx_subst_tm
  single G c :: ctx_subst_co

freevars
  G x :: fv_ctx_tm
  G c :: fv_ctx_co
  W x :: fv_rctx_tm



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%_ Pattern-specific stuff _%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

pattern_arg :: 'pattern_arg_' ::= {{ com Pattern arguments }}
  | \Rel a R       ::   :: Rel
  | \Irr a         ::   :: Irr
  | \Coe g         ::   :: Coe


pattern_args, PA :: 'pattern_args_' ::= {{ coq list pattern_arg }}
  | none                  ::   :: None {{ coq nil }}
  | PA , pattern_arg      ::   :: Cons {{ coq (cons [[pattern_arg]] [[PA]]) }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%__ Terminals __%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

terminals :: 'terminals_' ::=
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | -->               ::   :: step          {{ tex \longrightarrow }}
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall        {{ tex \forall }}
  | in                ::   :: in            {{ tex \in }}
  | notin             ::   :: notin         {{ tex \not\in }}
  | <=                ::   :: check         {{ tex \Leftarrow }}
  | =>                ::   :: infer         {{ tex \Rightarrow }}
  | =>*               ::   :: minfer        {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow         {{ tex \to }}
  | /\                ::   :: ilam          {{ tex \mathrm{\Lambda} }}   % Swag
  | <-|               ::   :: mapsfrom      {{ tex \mapsfrom }}
  | []                ::   :: box           {{ tex \Box }}
  | |-                ::   :: entails       {{ tex \vdash }}
  | -|                ::   :: produces      {{ tex \dashv }}
  | |=                ::   :: hs_entails    {{ tex \vDash }}
  | |==               ::   :: hs_entaill    {{ tex \vDash }}
  | /=                ::   :: neq           {{ tex \neq }}
  | |>                ::   :: cast          {{ tex \triangleright }}
  | ok                ::   :: ok            {{ tex \ \mathsf{ok} }}
  | _                 ::   :: blank         {{ tex \_ }}
  | ~>                ::   :: produce       {{ tex \leadsto }}
  | ~>*               ::   :: multistep     {{ tex \leadsto^{\ast} }}
  | ~>h               ::   :: steph         {{ tex \leadsto }}
  | empty             ::   :: empty         {{ tex \varnothing }}
  | hole              ::   :: hole          {{ tex \circ }}
  | fv                ::   :: fv            {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom           {{ tex \mathsf{dom} }}
  | ~                 ::   :: twiddle       {{ tex \sim }}
  | ~~                ::   :: compatible    {{ tex \asymp }}
  | '|'               ::   :: bar           {{ tex | }}
  | o                 ::   :: bullet        {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | as                ::   :: as
  | |=>|              ::   :: erasesto      {{ tex \mathrel{|\Rightarrow|} }}
  | |-=               ::   :: turneq        {{ tex \vdash_{=} }}
  | refl2             ::   :: refl2         {{ tex \mathbf{refl_2}  }}
  | ++                ::   :: concat        {{ tex \mathop{++} }}
  | {                 ::   :: lbrace        {{ tex \lbrace }}
  | }                 ::   :: rbrace        {{ tex \rbrace }}
  | +>                ::   :: partialmap    {{ tex \mathrel{+\!\!\!\!\!\!\rightarrow} }}

formula, Fm {{tex \psi}} :: 'formula_' ::=
  | judgement                ::   :: judgement
  | x : A  in G              ::   :: inG
    {{ coq binds [[x]] (Tm [[A]]) [[G]] }}
  | x : R in W               ::   :: inW
    {{ coq binds [[x]] [[R]] [[W]] }}

  | c : phi  in G         ::   :: inGP
    {{ coq binds [[c]] (Co [[phi]]) [[G]] }}

  | F : sig_sort in S           ::   :: inGFam
    {{ coq binds [[F]] ([[sig_sort]]) [[S]] }}

  | x in D                   ::   :: availx
    {{ coq AtomSetImpl.In [[x]] [[D]] }}
  | c in D                   ::   :: avail
    {{ coq AtomSetImpl.In [[c]] [[D]] }}
  | c not relevant in g      ::   :: notrelevant
    {{ coq [[c]] \notin (fv_relevant [[g]]) }}
  | x notin D            ::   :: notInDx
    {{ coq ~ AtomSetImpl.In [[x]] [[D]] }}
  | ctx_uniq G               ::   :: uniqGx
    {{ coq uniq [[G]] }}
    {{ tex \emph{uniq} \ [[G]] }}
  | rctx_uniq W              ::   :: uniqWx
    {{ coq uniq [[W]] }}
    {{ tex \emph{uniq}([[W]]) }}
  | c notin D                ::   :: notInDc
    {{ coq ~ AtomSetImpl.In [[c]] [[D]] }}
  | T notin dom S            ::   :: notInST
    {{ coq ~ AtomSetImpl.In [[T]] (dom [[S]]) }}
  | F notin dom S            ::   :: notInSF
    {{ coq ~ AtomSetImpl.In [[F]] (dom [[S]]) }}
  | N1 < N2                  ::   :: length_less
    {{ coq [[N1]] < [[N2]] }}
  | N1 <= N2                 ::   :: length_leq
    {{ coq [[N1]] <= [[N2]] }}{{ tex [[N1]] \leq [[N2]] }}
  | nu_rho nu                ::   :: nu_rho_eq
    {{ coq (nu_rho [[ nu]]) }} {{ tex [[nu]] = \rho }}
  | R1 = R2                  ::   :: role_equal
    {{ coq ([[R1]] = [[R2]]) }}
  | a = b                    ::   :: equal
    {{ coq ([[a]] = [[b]]) }}
  |  phi1 =  phi2       ::   :: erasedphi
    {{ coq ([[phi1]] = [[phi2]]) }}
  | G1 = G2                  ::   :: equalctx
    {{ coq ([[G1]] = [[G2]]) }}
  | g1 = g2                  ::   :: equalco
    {{ coq ([[g1]] = [[g2]]) }}
  | not Fm              ::   :: not
    {{ coq not ([[Fm]]) }}
    {{ tex \neg [[Fm]] }}
  | Fm1 /\ Fm2     ::   :: and
    {{ coq [[Fm1]] /\ [[Fm2]] }}
    {{ tex [[Fm1]] \wedge [[Fm2]] }}
  | Fm1 \/ Fm2     ::   :: or
    {{ coq [[Fm1]] \/ [[Fm2]] }}
    {{ tex [[Fm1]] \vee [[Fm2]] }}
  | Fm1 implies Fm2     ::   :: implies
    {{ coq [[Fm1]] -> [[Fm2]] }}
    {{ tex [[Fm1]] \Rightarrow [[Fm2]] }}
  | ( Fm )              ::   :: Paren
    {{ coq ([[Fm]]) }}
  | [ Fm ]              ::   :: Regular
    {{ coq ([[Fm]]) }}
    {{ tex \suppress{[[Fm]]} }}
  | c : (a : A ~ b : B) in G ::   :: Alt
    {{ coq True }}
  | nolc A                   ::   :: NoLC
    {{ com suppress lc hypothesis generated by Ott }}
    {{ coq True }}
    {{ tex      }}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%__ Coq Definitions necessary to specify the semantics __%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

embed {{ coq

Definition app_role (rr : appflag) : role :=
  match rr with
  | Rho _ => Nom
  | Role r => r
  end.

Definition app_rho (rr : appflag) : relflag :=
  match rr with
  | Rho p => p
  | Role _ => Rel
  end.

Definition nu_rho (nu : appflag) : Prop :=
 match nu with
 | Rho _ => True
 | Role _ => False
 end.

Definition min (r1 : role) (r2 : role) : role :=
  match r1 , r2 with
  | Nom, _   => Nom
  | _  , Nom => Nom
  | Rep, Rep => Rep
  end.

Definition max (r1 : role) (r2 : role) : role :=
  match r1 , r2 with
  | _, Rep   => Rep
  | Rep, _   => Rep
  | Nom, Nom => Nom
  end.

Definition lte_role (r1 : role) (r2 : role) : bool :=
  match r1 , r2 with
  | Nom, _   => true
  | Rep, Nom => false
  | Rep, Rep => true
  end.

Parameter str : bool.
Definition param (r1 : role) (r2 : role) :=
  if str then r1 else min r1 r2.

Fixpoint erase_tm (a : tm) (r : role) : tm :=
   match a with
   | a_Star    => a_Star
   | a_Var_b n => a_Var_b n
   | a_Var_f x => a_Var_f x
   | a_Abs rho A b => a_UAbs rho (erase_tm b r)
   | a_UAbs rho b => a_UAbs rho (erase_tm b r)
   | a_App a (Role R) b => a_App (erase_tm a r) (Role R) (erase_tm b r)
   | a_App a (Rho Rel) b => a_App (erase_tm a r) (Rho Rel) (erase_tm b r)
   | a_App a (Rho Irrel) b => a_App (erase_tm a r) (Rho Irrel) a_Bullet
   | a_Fam F => a_Fam F
   | a_Pi rho A B => a_Pi rho (erase_tm A r) (erase_tm B r)
   | a_Conv a r1 g => if (lte_role r1 r) then
                        erase_tm a r else
                                 a_Conv (erase_tm a r) r1 g_Triv
   | a_CPi phi B => a_CPi (erase_constraint phi r) (erase_tm B r)
   | a_CAbs phi b => a_UCAbs (erase_tm b r)
   | a_UCAbs b => a_UCAbs (erase_tm b r)
   | a_CApp a g => a_CApp (erase_tm a r) g_Triv
   | a_DataCon K => a_Star  (* a_DataCon K *)
   | a_Case a brs => a_Star (* a_Case (erase_tm a) (erase_brs brs) *)
   | a_Bullet => a_Bullet
   | a_Pattern R a1 F b1 b2 => a_Pattern R (erase_tm a1 r) F (erase_tm b1 r) (erase_tm b2 r)
   | a_Sub _ a => erase_tm a r
   end
with erase_brs (x : brs) (r:role): brs :=
   match x with
   | br_None => br_None
   | br_One k a y => br_One k (erase_tm a r) (erase_brs y r)
   end
with erase_constraint (phi : constraint) (r:role): constraint :=
   match phi with
   | Eq A B A1 R => Eq (erase_tm A R) (erase_tm B R) (erase_tm A1 R) R
   end.

Definition erase_sort s r :=
 match s with
 | Tm a => Tm (erase_tm a r)
 | Co p => Co (erase_constraint p r)
end.


Definition erase_csort s r :=
 match s with
 | Cs a Rs => Cs (erase_tm a r) Rs
 | Ax p a A R Rs => Ax (erase_tm p r) (erase_tm a r) (erase_tm A r) R Rs
end.

Definition erase_context G r := map (fun s => erase_sort s r) G.
Definition erase_sig S r := map (fun s => erase_csort s r) S.

Fixpoint pattern_length (a : tm) : nat := match a with
   a_Fam F => 0
 | a_App a nu b => pattern_length a + 1
 | a_CApp a g_Triv => pattern_length a + 1
 | _ => 0
 end.

Fixpoint vars_Pattern (p : tm) := match p with
   | a_Fam F => nil
   | a_App p1 (Role _) (a_Var_f x) => vars_Pattern p1 ++ [ x ]
   | a_App p1 (Rho Irrel) a_Bullet => vars_Pattern p1
   | a_CApp p1 g_Triv => vars_Pattern p1
   | _ => nil
   end.

(* -------------- A specific signature with Fix ------------ *)
Definition Fix : atom.
  pick fresh F.
  exact F.
Qed.

Definition FixVar1 : atom.
 pick fresh F.
 exact F.
Qed.

Definition FixVar2 : atom.
 pick fresh F.
 exact F.
Qed.

Definition FixPat : tm := a_App (a_App (a_Fam Fix) (Rho Irrel) (a_Var_f FixVar1)) (Rho Rel) (a_Var_f FixVar2).

Definition FixDef : tm := a_App (a_Var_f FixVar2) (Rho Rel) (a_App (a_App (a_Fam Fix) (Rho Irrel) a_Bullet) (Rho Rel) (a_Var_f FixVar2)).

Definition FixTy : tm := a_Var_f FixVar1.

Definition an_toplevel : sig := Fix ~ Ax FixPat FixDef FixTy Rep (Nom :: [Nom]).

Definition toplevel : sig := erase_sig an_toplevel Nom.

Fixpoint range (L : role_context) : roles :=
  match L with
  | nil => nil
  | (x,R) :: L' => range(L') ++ [ R ]
  end.

}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%__ "Syntactic" definitions __%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
JSubRole :: '' ::=

defn
R1 <= R2  ::  :: SubRole :: ''
{{ com Subroling judgement }}
{{ tex [[R1]] \leq [[R2]] }}
by

------------ :: NomBot
Nom <= R


------------ :: RepTop
R <= Rep


------------ :: Refl
R <= R

R1 <= R2
R2 <= R3
--------- :: Trans
R1 <= R3

defns
   JPath :: '' ::=

defn
Path a = F @ Rs  ::  :: Path :: 'Path_'
{{ com Type headed by constant (partial function) }}
{{ tex \mathsf{Path} \ [[a]] = [[F]] @ [[Rs]] }}
by

F : A @ Rs in toplevel
--------------------- :: AbsConst
Path F = F @ Rs

F : p ~ a : A/R1 @ Rs in toplevel
--------------------------------- :: Const
Path F = F @ Rs

Path a = F @ R1,Rs
---------------------------- :: App
Path (a R1 b') = F @ Rs

Path a = F @ Rs
---------------------- :: IApp
Path (a - []) = F @ Rs

Path a = F @ Rs
---------------------- :: CApp
Path (a [o]) = F @ Rs


defns
JPatCtx :: '' ::=

defn
W ; G |= F , A ; p : B  :: :: PatternContexts :: 'PatCtx_'
{{ com Contexts generated by a pattern (variables bound by the pattern) }}
{{ tex [[W]] ; [[G]] [[|=]] [[p]] :_[[F]] [[B]] \Rightarrow [[A]] }}
by

------------------------------ :: Const
empty ; empty |= F, A;  F : A

W ; G |= F, B; p : all + x : A' -> A
---------------------------------------- :: PiRel
W, x : R ; G, x : A' |= F, B; p R x : A

W ; G |= F, B; p : all - x : A' -> A
--------------------------------------- :: PiIrr
W ; G, x : A' |= F, B; p - [] : A

W ; G |= F, B; p : all c : phi. A
------------------------------------ :: CPi
W ; G, c : phi |= F, B; p [o] : A


defns
JRename :: '' ::=

defn
rename p -> a to p' -> a' excluding D and D' :: :: Rename :: 'Rename_'
{{ com rename with fresh variables }}
{{ tex \mathsf{rename} \ [[p]] \rightarrow [[a]] \ \mathsf{to} \ [[p']] \rightarrow [[a']] \ \mathsf{excluding} \ [[D]] \ \mathsf{and} \ [[D']] }}
by

------------------------------------------------ :: Base
rename F -> a to F -> a excluding D and emptyD

rename p1 -> a1 to p2 -> a2 excluding D and D'
y notin (D, D')
--------------------------------------------------------------------------- :: AppRel
rename (p1 R x) -> a1 to (p2 R y) -> (a2 {`y/x`}) excluding D and (D',y)

rename p1 -> a1 to p2 -> a2 excluding D and D'
------------------------------------------------------------ :: AppIrrel
rename (p1 - []) -> a1 to (p2 - []) -> a2 excluding D and D'

rename p1 -> a1 to p2 -> a2 excluding D and D'
----------------------------------------------------------- :: CApp
rename (p1 [o]) -> a1 to (p2 [o]) -> a2 excluding D and D'

defns
JMatchSubst :: '' ::=

defn
match a1 with p -> b1 +> b2 :: :: MatchSubst :: 'MatchSubst_'
{{ com match and substitute }}
{{ tex \mathsf{match} \ [[a1]] \ \mathsf{with} \ [[p]] \rightarrow [[b1]] [[+>]] [[b2]] }}
by

----------------------------------------- :: Const
match F with F -> b +> b

match a1 with p1 -> b1 +> b2
------------------------------------------------------- :: AppRelR
match (a1 R a) with (p1 R x) -> b1 +> (b2 {`a/x`})

match a1 with p1 -> b1 +> b2
-------------------------------------------------------- :: AppIrrel
match (a1 - a) with (p1 - []) -> b1 +> b2

match a1 with a2 -> b1 +> b2
------------------------------------------------------ :: CApp
match (a1 [o]) with (a2 [o]) -> b1 +> b2


defns
JPatData :: '' ::=

defn
uncurry p = F @ PA :: :: PatData :: 'PatData_'
{{ com Pattern data (head & arguments) }}
by


-------------------- :: Head
uncurry F = F @ none


uncurry p = F @ PA
---------------------------------- :: Rel
uncurry (p R a) = F @ PA, \Rel a R

% TODO: other cases (left out for now for development purposes)

% TODO: If possible, I think we should just scrap that relation and
%       use `pattern` + `head_const` & `pattern_args` instead.
%       If needed, we can always add these two functions right after
%       the definition of `pattern`

defns
JIsPattern :: '' ::=

defn
pattern p  :: :: Pattern :: 'Pattern_'
by


--------- :: Head
pattern F


pattern p
--------------- :: Rel
pattern (p R a)


pattern p
--------------- :: Irr
pattern (p - a)


pattern p
--------------- :: Coe
pattern (p [g])



defns
JSubPat :: '' ::=

defn
subpattern p' p :: :: SubPat :: 'SubPat_'
{{ com Subpattern }}
by

% The premise is just here to check that p is indeed a pattern
pattern p
------------------ :: Refl
subpattern p p


subpattern p' p
--------------------- :: Rel
subpattern p' (p R x)

subpattern p' p
---------------------- :: Irr
subpattern p' (p - [])


subpattern p' p
--------------------- :: Coe
subpattern p' (p [o])



defns
JTmPatternAgree :: '' ::=

defn
a <-> p :: :: tm_pattern_agree :: 'tm_pattern_agree_'
{{ com term and pattern agree }}
{{ tex [[a]] [[<->]] [[p]] }}
by

----------------------------:: Const
 F <-> F

a1 <-> p1
----------------------------:: AppRelR
(a1 R a2) <-> (p1 R x)

a1 <-> p1
----------------------------:: AppIrrel
(a1 - a) <-> (p1 - [])

a1 <-> p1
-----------------------------:: CApp
(a1 [o]) <-> (p1 [o])

defns
JTmSubPatternAgree :: '' ::=

defn
a + = p :: :: tm_subpattern_agree :: 'tm_subpattern_agree_'
{{ com sub-pattern agrees with term }}
{{ tex [[a]] \sqsubseteq [[p]] }}
by

a <-> p
---------:: Base
a + = p

a + = p
-------------- :: AppRelR
a + = (p R x)

a + = p
--------------- :: AppIrrel
a + = (p - [])

a + = p
----------------- :: CAppp
a + = (p [o])


defns
JSubTmPatternAgree :: '' ::=

defn
a = p + :: :: subtm_pattern_agree :: 'subtm_pattern_agree_'
{{ com sub-term agrees with pattern }}
{{ tex [[a]] \sqsupseteq [[p]] }}
by

a <-> p
---------:: Base
a = p +

a = p +
-------------- :: App
a nu a2 = p +

a = p +
----------------- :: CAppp
a [o] = p +


defns
   JValuePath :: '' ::=

defn
ValuePath a +> F  ::  :: ValuePath :: 'ValuePath_'
{{ com Type headed by constant (role-sensitive partial function used in value) }}
{{ tex \mathsf{ValuePath} \ [[a]] [[+>]] [[F]] }}
by

F : A @ Rs in toplevel
--------------------- :: AbsConst
ValuePath F +> F

F : p ~ a : A/R1 @ Rs in toplevel
---------------------------------- :: Const
ValuePath F +> F

ValuePath a +> F
---------------------------- :: App
ValuePath (a nu b') +> F

ValuePath a +> F
---------------------- :: CApp
ValuePath (a [o]) +> F


defns
   JCasePath :: '' ::=

defn
CasePath R a +> F  ::  :: CasePath :: 'CasePath_'
{{ com Type headed by constant (role-sensitive partial function used in case) }}
{{ tex \mathsf{CasePath}_{[[R]]}\ [[a]] [[+>]] [[F]] }}
by

ValuePath a +> F
F : A @ Rs in toplevel
----------------------- :: AbsConst
CasePath R a +> F

ValuePath a +> F
F : p ~ b : A/R1 @ Rs in toplevel
not (R1 <= R)
----------------------------------- :: Const
CasePath R a +> F

ValuePath a +> F
F : p ~ b : A/R1 @ Rs in toplevel
not (a  =  p +)
------------------------------------- :: UnMatch
CasePath R a +> F

defns
JApplyArgs :: '' ::=

defn
apply args a to b +> b' :: :: ApplyArgs :: 'ApplyArgs_'
{{ com apply arguments of a (headed by a constant) to b }}
{{ tex \mathsf{apply~args} \ [[a]] \ \mathsf{to} \ [[b]] [[+>]] [[b']] }}
by

----------------------------------- :: Const
apply args F to b +> b

apply args a to b +> b'
------------------------------------------------------- :: App
apply args a nu a' to b +> b' nu a'

apply args a to b +> b'
------------------------------------------------------- :: CApp
apply args a [o] to b +> b' [o]


defns
JValue :: '' ::=

defn
Value R A  ::   :: Value    :: 'Value_'
{{ com values }}
{{ tex \mathsf{Value}_{[[R]]}\ [[A]] }}
by

------- :: Star
Value R TYPE

-------------------------- :: Pi
Value R all rho x : A -> B

-------------------- :: CPi
Value R all c : phi. B

--------------------- :: AbsRel
Value R \ + x:A. a

--------------------- :: UAbsRel
Value R \ + x. a

Value R a
--------------------- :: UAbsIrrel
Value R \ - x. a

--------------------- :: CAbs
Value R /\c:phi.a

--------------------- :: UCAbs
Value R /\c .a

CasePath R a +> F
----------------- :: Path
Value R a


defns
   JValueType :: '' ::=

defn
ValueType R A ::   :: value_type :: 'value_type_'
{{ com Types with head forms (erased language) }}
{{ tex \mathsf{ValueType}_{[[R]]}\ [[A]] }}
by

------- :: Star
ValueType R TYPE

-------------------------- :: Pi
ValueType R all rho x : A  -> B

-------------------- :: CPi
ValueType R all c : phi. B

CasePath R a +> F
------------------------ :: ValuePath
ValueType R a


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%__ Definitions for consistency proof __%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
   Jconsistent :: '' ::=

defn
   consistent a b R ::  :: consistent :: 'consistent_a_'
   {{ com (erased) types do not differ in their heads }}
  {{ tex \suppress{\mathsf{consistent}_{[[R]]}\ [[a]] \ [[b]] } }}
by

---------------------- :: Star
consistent TYPE TYPE R

------------------------ :: Pi
consistent (all rho x1:A1 -> B1) (all rho x2:A2 -> B2) R'

------------------------ :: CPi
consistent (all c1:phi1. A1) (all c2 :phi2. A2) R

CasePath R a1 +> F
CasePath R a2 +> F
------------------------ :: CasePath
consistent a1 a2 R

not ValueType R b
---------------------- :: Step_R
consistent a b R

not ValueType R a
---------------------- :: Step_L
consistent a b R


defns
  Jroleing :: '' ::=

defn
  W |= a : R ::  :: roleing :: 'role_a_'
  {{ com Roleing judgment }}
  {{ tex [[W]] \vDash [[a]] : [[R]] }}
by
rctx_uniq W
------------------- :: Bullet
W |= [] : R

rctx_uniq W
---------------------  :: Star
W |= TYPE : R

rctx_uniq W
x : R in W
R <= R1
------------------------------- :: Var
W |= x : R1

W , x : Nom |=  a : R
------------------------------------ :: Abs
W |= (\rho x.a) : R

W |= a : R
W |= b : Nom
----------------------------- :: App
W |= (a rho b) : R

W |= a : R
W |= b : R1
----------------------------- :: TApp
W |= a R1 b : R

W |= A : R
W , x : Nom |= B : R
---------------------------------------- :: Pi
W |= (all rho x:A -> B) : R

W |= a : R1
W |= b : R1
W |= A : R0
W |= B : R
----------------------------------------------- :: CPi
W |= (all c:a ~ b : A / R1. B) : R

W |= b : R
---------------------------------- :: CAbs
W |= (/\c. b) : R

W |= a : R
------------------------- :: CApp
W |= (a [o]) : R

rctx_uniq W
F : A @ Rs in toplevel
--------------------------- :: Const
W |= F : R

rctx_uniq W
F : p ~ a : A / R @ Rs in toplevel
---------------------------------- :: Fam
W |= F : R1

W |= a : R
W |= b1 : R1
W |= b2 : R1
--------------------------------------- :: Pattern
W |= case R a of F => b1 | _ => b2 : R1

defns
JChk :: '' ::=

defn
rho => check x in A ::    :: RhoCheck :: 'Rho_'
{{ tex ([[rho]] = +) \vee ([[x]]\not\in\mathsf{fv}\; [[A]]) }}
{{ com irrelevant argument check }}
by

nolc A
-------------------- :: Rel
+ => check x in A

x notin fv A
-------------------- :: IrrRel
- => check x in A


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%__ Implicit (or erased) language reductions __%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defns
  Jpar :: '' ::=

defn
 W |= a => b / R ::  :: Par :: 'Par_'
{{ tex [[W]] \vDash [[a]] [[=>]]_{[[R]]} [[b]] }}
{{ com parallel reduction (implicit language) }}
by

W |= a : R
------------------------- :: Refl
W |= a => a  / R


W |= a => (\rho x.a') / R
W |= b => b' / Nom
---------------------------------------- :: Beta
W |= a rho b => a' { b' / x } / R

W |= a => a' / R
W |= b => b' / (app_role nu)
---------------------------------------------- :: App
W |= a nu b => a' nu b' / R

W |= a => (/\c .a')  / R
----------------------- :: CBeta
W |= a [o] => a' { o / c } / R

W |= a => a' / R
----------------------- :: CApp
W |= a [o] => a' [o] / R

W , x : Nom |= a => a' / R
---------------------------------------------------- :: Abs
W |= \ rho x. a => \ rho x. a' / R

W |= A => A' / R
W , x : Nom |= B => B' / R
--------------------------------------------------------- :: Pi
W |= all rho x:A -> B => all rho x:A' -> B' / R

W |= a => a' / R
------------------------------------------ :: CAbs
W |= /\c . a => /\c . a' / R

W |= A => A' / R0
W |= a => a' / R1
W |= b => b' / R1
W |= B => B' / R
------------------------------------------------------------------ :: CPi
W |= all c:a~b:A/R1. B => all c:a'~b':A'/R1. B' / R

F : F ~ b : A/R1 @ Rs in toplevel
R1 <= R
rctx_uniq W
------------------------------------------------------------------- :: AxiomBase
W |= F => b / R

F : p ~ b : A/R1 @ Rs in toplevel
a + = p /\ not (a <-> p)
W |= a => a' / R
W |= a1 => a1' / (app_role nu)
rename p -> b to p' -> b' excluding (dom W, fv p) and D'
match (a' nu a1') with p' -> b' +> a2
R1 <= R
------------------------------------------------------------------- :: AxiomApp
W |= a nu a1 => a2 / R

F : p ~ b : A/R1 @ Rs in toplevel
a + = p /\ not (a <-> p)
W |= a => a' / R
rename p -> b to p' -> b' excluding (dom W, fv p) and D'
match (a' [o]) with p' -> b' +> a2
R1 <= R
------------------------------------------------------------------- :: AxiomCApp
W |= a [o] => a2 / R

W |= a => a' / R
W |= b1 => b1' / R0
W |= b2 => b2' / R0
------------------------------------------------------------------------------- :: Pattern
W |= (case R a of F => b1 | _ => b2) => (case R a' of F => b1' | _ => b2') / R0

W |= a => a' / R
W |= b1 => b1' / R0
W |= b2 => b2' / R0
CasePath R a' +> F
apply args a' to b1' +> b
--------------------------------------------- :: PatternTrue
W |= (case R a of F => b1 | _ => b2) => b [o] / R0

W |= a => a' / R
W |= b1 => b1' / R0
W |= b2 => b2' / R0
Value R a'
not (CasePath R a' +> F)
------------------------------------------------ :: PatternFalse
W |= (case R a of F => b1 | _ => b2) => b2' / R0


defn
W |= a =>* b / R ::   :: MultiPar :: 'MP_'
{{ tex [[W]] [[|=]] [[a]] [[=>*]]_[[R]] [[b]] }}
{{ com multistep parallel reduction }}
by

------------------------- :: Refl
W |= a =>* a / R

W |= a => b / R
W |= b =>* a' / R
-------------------------- :: Step
W |= a =>* a' / R

defn
W |= a <=> b / R ::   :: joins :: ''
{{ tex [[W]] [[|=]] [[a]] [[<=>]]_[[R]] [[b]] }}
{{ com parallel reduction to a common term }}
by

W |= a1 =>* b / R
W |= a2 =>* b / R
-------------------------- :: join
W |= a1 <=> a2 / R



defns
 Jbeta :: '' ::=

defn
|= a > b / R  ::     :: Beta :: 'Beta_'
{{ com primitive reductions on erased terms }}
by

Value R1 (\rho x. v)
------------------------------------ :: AppAbs
|= (\rho x.v) rho b > v { b / x } / R1


------------------------------- :: CAppCAbs
|= (/\c .a') [o] > a' { o / c } / R


F : p ~ b : A/R1 @ Rs in toplevel
rename p -> b to p1 -> b1 excluding (fv a, fv p) and D'
match a with p1 -> b1 +> b'
R1 <= R
-------------------------------------------------------- :: Axiom
|= a > b' / R

CasePath R a +> F
apply args a to b1 +> b1'
------------------------------------------ :: PatternTrue
|= case R a of F => b1 | _ => b2 > b1' [o] / R0

Value R a
not (CasePath R a +> F)
------------------------------------------ :: PatternFalse
|= case R a of F => b1 | _ => b2 > b2 / R0

defn
 |= a ~> b / R ::   :: reduction_in_one :: 'E_'
{{ com single-step head reduction for implicit language }}
by

|= a ~> a' / R1
-------------------------  :: AbsTerm
|= \- x.a ~> \- x.a' / R1

|= a ~> a' / R1
-------------------------  :: AppLeft
|= a nu b ~> a' nu b / R1

|= a  ~> a' / R
-----------------------------   :: CAppLeft
|= a [o]  ~> a' [o] / R

|= a ~> a' / R
----------------------------------------------------------------------- :: Pattern
|= case R a of F => b1 | _ => b2 ~> case R a' of F => b1 | _ => b2 / R0

|= a > b / R
----------------------------- :: Prim
|= a ~> b / R


defn

|= a ~>* b / R ::  :: reduction :: ''
{{ com multistep reduction }}
by

------------------- :: Equal
|= a ~>* a / R

|= a ~> b / R
|= b ~>* a' / R
------------------- :: Step
|= a ~>* a' / R



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%__ Implicit (or erased) language type system __%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%__ Branch Typing

defns
JBranchTyping :: '' ::=

defn
G |= case R a : A of b : B -> C | C' ::    :: BranchTyping :: 'BranchTyping_'
{{ com Branch Typing (aligning the types of case) }}
{{ tex [[G]] \vDash \mathsf{case}_{[[R]]} \hspace{2pt} [[a]] : [[A]] \hspace{2pt} \mathsf{of} \hspace{2pt} [[b]] : [[B]] \Rightarrow [[C]] \ | \, [[C']] }}
by

ctx_uniq G
{{ lc_tm [[C]] }}
% ^ better way to do this? (hopefully making ott aware that C is lc)
------------------------------------------------------------- :: Base
G |= case R a : A of b : A -> all c : (a ~ b : A / R) . C | C

G, x : A |= case R a : A1 of b + x : B -> C | C'
------------------------------------------------------------------- :: PiRel
G |= case R a : A1 of b : all + x : A -> B -> all + x : A -> C | C'

G, x : A |= case R a : A1 of b - [] : B -> C | C'
------------------------------------------------------------------- :: PiIrrel
G |= case R a : A1 of b : all - x : A -> B -> all - x : A -> C | C'

G, c : phi |= case R a : A of b [o] : B -> C | C'
----------------------------------------------------------------- :: CPi
G |= case R a : A of b : all c : phi. B -> all c : phi. C | C'


%%__ Typing/equality/wellformedness __%%

defns
Jett :: '' ::=


defn
G |= phi ok ::    :: PropWff :: 'E_'
{{ com Prop wellformedness }}
by

G |= a : A
G |= b : A
[ G |= A : TYPE  ]
---------------------------  :: Wff
G |= a ~ b : A / R ok


%%__ Typing

defn
G |= a : A ::   :: Typing :: 'E_'
{{ com typing }}
by

|= G
---------------------  :: Star
G |= TYPE : TYPE

|= G
x:A in G
------------------ :: Var
G |= x : A

G, x:A |= B : TYPE
G |= A : TYPE
----------------------------------------- :: Pi
G |= all rho x:A -> B : TYPE

G, x:A  |= a : B
[ G |= A : TYPE  ]
rho => check x in a
---------------------------------- :: Abs
G |= \ rho x . a : ( all rho x:A -> B )

G |= b : all+ x : A -> B
G |= a : A
------------------------------------- :: App
G |= b + a : B { a / x }

G |= b : all+ x : A -> B
G |= a : A
Path b = F @ R, Rs
------------------------------------- :: TApp
G |= b R a : B { a / x }


G |= b : all - x : A -> B
G |= a : A
------------------------------------- :: IApp
G |= b - [] : B { a / x }


G |= a : A
G ; dom G |= A == B : TYPE / Rep
[ G |= B : TYPE ]
----------------------------- :: Conv
G |= a : B

G, c : phi |= B : TYPE
[ G |= phi ok ]
-------------------------------- :: CPi
G |= all c:phi. B : TYPE

G, c:phi |= a : B
[ G |= phi ok ]
------------------------------------------------- :: CAbs
G |= /\ c . a : all c:phi. B

G |= a1 : all c : (a ~ b : A / R) . B1
G ; dom G |= a == b : A / R
------------------------------------------- :: CApp
G |= a1 [ o ] : B1 { o / c }

|= G
F : A @ Rs in toplevel
[ empty |= A : TYPE ]
------------------------- :: Const
G |= F : A

|= G
F : p ~ a : A / R1 @ Rs in toplevel
[ empty |= A : TYPE ]
---------------------------- :: Fam
G |= F : A

G |= a : A
G |= F : A1
G |= b1 : B
G |= b2 : C
G |= case R a : A of F : A1 -> B | C
------------------------------------------ :: Case
G |= case R a of F => b1 | _ => b2 : C



%%__ Equalities

defn
G ; D |= phi1 == phi2  ::    :: Iso :: 'E_'
{{ com prop equality }}
by

G ; D |= A1 == A2 : A / R
G ; D |= B1 == B2 : A / R
--------------------------------------------- :: PropCong
G ; D |= A1 ~ B1 : A /R  == A2 ~ B2 : A /R

G ; D |= A == B : TYPE / R0
G |= A1 ~ A2 : A / R ok
G |= A1 ~ A2 : B / R ok
-------------------------------------------- :: IsoConv
G ; D |= A1 ~ A2 : A / R == A1 ~ A2 : B / R

G ; D |= all c:(a1 ~ a2 : A/R1). B1 == all c:(b1 ~ b2 : B/R2). B2 : TYPE / R'
---------------------------------------------------------------------------- :: CPiFst
G ; D |=  a1 ~ a2 : A/R1 == b1 ~ b2 : B/R2


defn

G ; D |= a == b : A / R ::     :: DefEq :: 'E_'
{{ com definitional equality }}
by

|= G
c: (a ~ b : A / R ) in G
c in D
-------------------- :: Assn
G ; D |= a == b : A / R

G |= a : A
------------------------- :: Refl
G ; D |= a == a : A / R

G ; D |= b == a : A / R
------------------------ :: Sym
G ; D |= a == b : A / R

G ; D |= a == a1 : A / R
G ; D |= a1 == b : A / R
------------------------------------- :: Trans
G ; D |= a == b : A / R

G ; D |= a == b : A / R1
R1 <= R2
---------------------------------------- :: Sub
G ; D |= a == b : A / R2

G |= a1 : B
[G |= a2 : B ]
|= a1 > a2 / R
--------------------------------  :: Beta
G ; D |= a1 == a2 : B / R

%% Rules related to functions

G ; D |=  A1 == A2 : TYPE/R'
G, x:A1; D |= B1 == B2 : TYPE/R'
%% this needed by weakening IH
[G |= A1 : TYPE]
%% these two needed by regularity
[G |= all rho x:A1 -> B1 : TYPE]
[G |= all rho x:A2 -> B2 : TYPE]
---------------------------------------------------------- :: PiCong
G ; D |= (all rho x:A1 -> B1) == (all rho x:A2 -> B2) : TYPE/R'


G, x:A1 ; D |= b1 == b2 : B/R'
[ G |= A1 : TYPE ]
rho => check x in b1
rho => check x in b2
-------------------------------------------------------------- :: AbsCong
G ; D |=  (\ rho x. b1) == (\ rho x. b2) : (all rho x:A1 -> B)/R'

G ; D |= a1 == b1 : (all + x:A -> B)/R'
G ; D |= a2 == b2 : A/ Nom
-------------------------------------- :: AppCong
G ; D |= a1 + a2 == b1 + b2 : (B { a2 / x })/R'

G ; D |= a1 == b1 : (all + x:A -> B)/R'
G ; D |= a2 == b2 : A/ R
Path a1 = F @ R, Rs
Path b1 = F' @ R, Rs'
------------------------------------------------ :: TAppCong
G ; D |= a1 R a2 == b1 R b2 : (B { a2 / x })/R'

G ; D |= a1 == b1 : (all - x:A -> B)/R'
G |= a : A
---------------------------------------------- :: IAppCong
G ; D |= a1 - [] == b1 - [] : (B { a / x })/R'


G ; D |= all rho x:A1 -> B1 == all rho x:A2 -> B2 : TYPE/R'
----------------------------------------------------------- :: PiFst
G ; D |=  A1 == A2 : TYPE/ R'

G ; D |= all rho x:A1 -> B1 == all rho x:A2 -> B2 : TYPE/R'
G ; D |= a1 == a2 : A1/ Nom
------------------------------------------------------------ :: PiSnd
G ; D |=  B1 {a1 /x}  == B2 {a2/x} : TYPE/R'

%% Rules related to Coercion Abstraction

G ; D |= a1 ~ b1 : A1/R == a2 ~ b2 : A2/R
G, c: a1 ~ b1 : A1/R ; D |= A == B : TYPE/R'
[G |= a1 ~ b1 : A1/R ok  ]
[G |= all c: a1 ~ b1 : A1/R. A : TYPE ]
[G |= all c: a2 ~ b2 : A2/R. B : TYPE ]
-------------------------------------------------------------------------- :: CPiCong
G ; D |= all c: a1 ~ b1 : A1/R . A  == all c: a2 ~ b2 : A2/R . B : TYPE/R'

G, c: phi1 ; D |= a == b : B/R
[ G |= phi1 ok ]
------------------------------------------------------------ :: CAbsCong
G ; D |=  (/\c . a) == (/\ c . b) : all c:phi1. B/R

G ; D |= a1 == b1 : (all c:(a ~ b : A/R). B)/R'
G ; dom G |= a == b : A/param R R'
------------------------------------------------ :: CAppCong
G ; D |= a1 [o] == b1 [o] : (B { o / c })/R'

G ; D |= all c:(a1 ~ a2 : A/R). B1 == all c:(a1'~ a2' : A'/R'). B2 : TYPE/R0
G ; dom G |= a1 == a2 : A/param R R0
G ; dom G |= a1' == a2' : A'/param R' R0
----------------------------------------------------------------------------- :: CPiSnd
G ; D |=  B1 { o / c} == B2 { o / c } : TYPE/R0

%% Other rules

G ; D |= a == b : A/R
G ; D |= a ~ b : A/R == a' ~ b' : A'/R'
------------------------------------------------ :: Cast
G ; D |= a' == b' : A'/R'

G ; D |= a == b : A/R
G ; dom G |= A == B : TYPE/Rep
[ G |= B : TYPE ]
-------------------------------------- :: EqConv
G ; D |= a == b : B/R

G ; D |= a ~ b : A/R1 == a' ~ b' : A'/R1
--------------------------------------------- :: IsoSnd
G ; D |= A == A' : TYPE/Rep

G ; D |= a == a' : A / R
G ; D |= b1 == b1' : B / R0
G ; D |= b2 == b2' : B / R0
------------------------------------------------------------------------------- :: PatCong
G ; D |= case R a of F => b1 | _ => b2 == case R a' of F => b1' | _ => b2' : B / R0

ValuePath a  +> F
ValuePath a' +> F
G |= a : all +x:A  -> B
G |= b : A
G |= a' : all +x:A  -> B
G |= b' : A
G ; D |= a R1 b == a' R1 b' : B { b / x } / R'
G ; dom G |= B {b/x} == B {b'/x} : TYPE / R'
-------------------------------------------------- :: LeftRel
G ; D |= a == a' : all + x: A -> B / R'

ValuePath a  +> F
ValuePath a' +> F
G |= a : all -x:A -> B
G |= b : A
G |= a' : all -x:A -> B
G |= b' : A
G ; D |= a - [] == a' - [] : B { b / x }/R'
G ; dom G |= B {b/x} == B {b'/x} : TYPE/R0
------------------------------------------------ :: LeftIrrel
G ; D |= a == a' : all -x: A -> B/R'


ValuePath a  +> F
ValuePath a' +> F
G |= a : all +x:A -> B
G |= b : A
G |= a' : all +x:A -> B
G |= b' : A
G ; D |= a + b == a' + b' : B { b / x }/R'
G ; dom G |= B {b/x} == B {b'/x} : TYPE/R0
----------------------------------------------- :: Right
G ; D |= b == b' : A/param R1 R'


ValuePath a  +> F
ValuePath a' +> F
G |= a  : all c:(a1 ~ a2:A/R1). B
G |= a' : all c:(a1 ~ a2:A/R1). B
G ; dom G |= a1 == a2 : A/R'
G ; D |= a [o] == a' [o] : B {o/c}/R'
-------------------------------------------- :: CLeft
G ; D |= a == a' : all c:(a1 ~ a2:A/R1). B/R'



%%__ Wellformedness

defn
|= G ::    :: Ctx  :: 'E_'
{{ com context wellformedness }}
by

---------- :: Empty
|= empty

|= G
G |= A : TYPE
x notin dom G
--------------------- :: ConsTm
|= G, x : A

|= G
G |= phi ok
c notin dom G
-------------------- :: ConsCo
|= G, c: phi

defns

Jsig :: '' ::=

defn
|= S ::    :: Sig :: 'Sig_'
{{ com signature wellformedness }}
by

------------ :: Empty
|= emptyS

|= S
empty |= A : TYPE
F notin dom S
-------------------- :: ConsConst
|= S, F : A @ Rs

|= S
F notin dom S
empty |= A : TYPE
W ; G |= F, A; p : B
G |= a : B
W |= a : R
-------------------------------- :: ConsAx
|= S, F : p ~ a : A/R @ range W


defns 
Jhiding :: '' ::=

defn
Rs1 <= Rs2 ::  :: RoleWeaken :: 'R_' 
by

-------------------- :: Nil
nilR <= nilR

R2 <= R1
Rs1 <= Rs2
-------------------- :: Cons
R1, Rs1 <= R2, Rs2



defn 
S1 <= S2 ::  :: SigWeaken :: 'S_' 
by

S1 <= S2
-------------------------- :: Forget
S1 <= S2, F : sig_sort

S1 <= S2
Rs1 <= Rs2
-----------------------------------------------------  :: Hide
S1 , F : A @ Rs1 <= S2 , F : p ~ a : A / R @ Rs2 

S1 <= S2
Rs1 <= Rs2
-----------------------------------------------------  :: WeakenConst
S1 , F : A @ Rs1 <= S2 , F : A @ Rs2

S1 <= S2
Rs1 <= Rs2
---------------------------------------------------------------  :: WeakenAxiom
S1 , F : p' ~ a : A / R @ Rs1 <= S2 , F : p ~ a : A / R @ Rs2 

------------------ :: Empty
emptyS <= emptyS

S1 <= S2
-----------------------------------------  :: Same
S1 , F : sig_sort <= S2 , F : sig_sort



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%__ Annotated language semantics __%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


defns
Jann :: '' ::=
defn
G |- phi ok ::   :: AnnPropWff :: 'An_'
{{ com prop wellformedness }}
by
%
% G |- a : A/R
% G |- b : B/R
% |A|R = |B|R
% ------------------------- :: Wff
% G |- a ~ b : A/R  ok
%
defn
G |- a : A / R ::  :: AnnTyping :: 'An_'
{{ com typing }}
by
%
% |- G
% ------------  :: Star
% G |- TYPE : TYPE/R
%
% |- G
% x : A/R in G
% ----------- :: Var
% G |- x : A/R
%
% G, x:A/R |- B : TYPE/R'
% [ G |- A : TYPE/R ]
% ------------------------------------ :: Pi
% G |- all rho x:A/R -> B : TYPE/R'
%
% [ G |- A : TYPE/R ]
% G, x:A/R |- a : B/R'
% rho => check x in | a |R'
% R <= R'
% ---------------------------------- :: Abs
% G |- \ rho x : A/R. a : (all rho x:A/R -> B)/R'
%
% G |- b : (all rho x:A/R -> B)/R'
% G |- a : A/R
% ------------------------------------- :: App
% G |- b rho R a : (B { a / x })/R'
%
% G |- a : A/R
% G ; dom G |- g : A ~ B : R
% G |- B : TYPE/R
% ----------------------------- :: Conv
% G |- a |>R g : B/R
%
% [ G |- phi ok ]
% G, c : phi |- B : TYPE/R
% -------------------------------- :: CPi
% G |- all c:phi. B : TYPE/R
%
% [ G |- phi ok ]
% G, c:phi |- a : B/R
% ------------------------------------------------- :: CAbs
% G |- /\ c: phi. a : (all c:phi. B)/R
%
% G |- a1 : (all c : a ~ b : A1/R. B)/ R'
% G ; dom G |- g : a ~ b : R
% ------------------------------------- :: CApp
% G |- a1 [ g ] : B { g / c } / R'
%
% |- G
% F ~ a : A/R in an_toplevel
% empty |- A : TYPE/R0
% ----------------------- :: Fam
% G |- F : A/R1
%
% R1 <= R2
% G |- a : A / R1
% ----------------- :: SubRole
% G |- sub R1 a : A / R2
%
%
defn
G ; D |- g : phi1 == phi2 ::  :: AnnIso :: 'An_'
{{ tex [[G]];[[D]][[|-]] [[g]] : [[phi1]] \sim [[phi2]] }}
{{ com coercion between props }}
by
%
% G ; D |- g1 : A1 ~ A2 : R
% G ; D |- g2 : B1 ~ B2 : R
% G |- A1 ~ B1 : A/R ok
% G |- A2 ~ B2 : A/R ok
% ------------------------------------------------------------ :: PropCong
% G ; D |- (g1 ~A g2) : (A1 ~ B1 : A/R) == (A2 ~ B2 : A/R)
%
% G ; D |- g : all c:phi1. A2 ~ all c:phi2. B2 : R
% --------------------------------------- :: CPiFst
% G ; D |- cpiFst g : phi1 == phi2
%
% G ; D |- g : phi1 == phi2
% ---------------------------- :: IsoSym
% G ; D |- sym g : phi2 == phi1
%
% G; D |- g : A ~ B : R
% G |- a1 ~ a2 : A/R ok
% G |- a1' ~ a2' : B/R ok
% |a1|R = |a1'|R
% |a2|R = |a2'|R
% -------------------------------------- :: IsoConv
% G ; D |- conv (a1 ~ a2 : A/R) (a1' ~ a2' : B/R) g : (a1 ~ a2 : A/R) == (a1' ~ a2' : B/R)
%
%

defn
G ; D |- g : A ~ B : R ::  :: AnnDefEq :: 'An_'
{{ com coercion between types }}
{{ tex [[G]]; [[D]] \vdash [[g]] [[:]] [[A]] \sim_[[R]] [[B]] }}
by
%
% |- G
% c: a ~ b : A/R in G
% c in D
% ------------------- :: Assn
% G ; D |- c : a ~ b : R
%
% G |- a : A/R
% ----------------------------- :: Refl
% G ; D |- refl a : a ~ a : R
%
% G |- a : A/R
% G |- b : B/R
% |a|R = |b|R
% G ; dom G |- g : A ~ B : R
% ----------------------------- :: EraseEq
% G ; D |- refl2 a b g : a ~ b : R
%
%
% G |- b : B/R
% G |- a : A/R
% [ G ; dom G |- g1 : B ~ A : R ]
% G ; D |- g : b ~ a : R
% -------------------------- :: Sym
% G ; D |- sym g : a ~ b : R
%
% G ; D |- g1 : a ~ a1 : R
% G ; D |- g2 : a1 ~ b : R
% [ G |- a : A/R ]
% [ G |- a1 : A1/R ]
% [ G ; dom G |- g3 : A ~ A1 : R ]
% ------------------------------------- :: Trans
% G ; D |- (g1 ; g2) : a ~ b : R
%
%
% G |- a1 : B0/R
% G |- a2 : B1/R
% |B0|R = |B1|R
% |= |a1|R > |a2|R / R
% --------------------------------  :: Beta
% G ; D |- red a1 a2 : a1 ~ a2 : R
%
%
% %% Note: need to include {x/x} to emphasize that x is free in B2 for
% %% the locally nameless backend.
% %% Need all three assns, so that we know A1, A2, B1, B2, B3 all have kind TYPE
% G ; D |- g1 : A1 ~ A2 : R'
% G, x : A1/R ; D |- g2 : B1 ~ (# B2 {{{ x / x }}} #) : R'
% B3 = B2 { x |>R' sym g1 / x }
% G |- all rho x:A1/R -> B1 : TYPE/R'
% G |- all rho x:A1/R -> B2 : TYPE/R'
% G |- all rho x:A2/R -> B3 : TYPE/R'
% [R <= R']
% ---------------------------------------------------------- :: PiCong
% G ; D |- all rho R x:g1 -> g2 : (all rho x:A1/R -> B1) ~ (all rho x:A2/R -> B3) : R'
%
% G ; D |- g1 : A1 ~ A2 : R
% G, x : A1/R ; D |- g2 : b1 ~ (# b2 {{{x / x}}} #) : R'
% b3 = b2 { x |>R' sym g1 / x }
% [ G |- A1 : TYPE/R ]
% G |- A2 : TYPE/R
% rho => check x in | b1 |R'
% rho => check x in | b3 |R'
% [G |- (\ rho x:A1/R. b2) : B/R']
% [R <= R' ]
% ------------------------------------------------------------------ :: AbsCong
% G ; D |- (\rho R x:g1. g2) : (\ rho x:A1/R. b1) ~ (\ rho x :A2/R. b3) : R'
%
% % really want heterogenous equality here.
% %% NOTE: we know that G |- g3 : A ~ B  must hold (b/c reg), but adding it as
% %% an extra assumption for the erasure proof.
% G ; D |- g1 : a1 ~ b1 : R'
% G ; D |- g2 : a2 ~ b2 : R
% G |- a1 rho R a2 : A/R'
% G |- b1 rho R b2 : B/R'
% [ G ; dom G |- g3 : A ~ B : R' ]
% -------------------------------------- :: AppCong
% G ; D |- g1 rho R g2 : a1 rho R a2 ~ b1 rho R b2 : R'
%
%
% G ; D |- g : all rho x:A1/R -> B1 ~ all rho x:A2/R -> B2 : R'
% --------------------------------------- :: PiFst
% G ; D |- piFst g : A1 ~ A2 : R
%
% G ; D |- g1 : all rho x:A1/R -> B1  ~ all rho x:A2/R -> B2 : R'
% G ; D |- g2 : a1 ~ a2 : R
% G |- a1 : A1/R
% G |- a2 : A2/R
% --------------------------------------- :: PiSnd
% G ; D |- g1 @ g2 : (# B1 {a1 /x} #) ~ (# B2 {a2/x} #) : R'
%
%
% G ; D |- g1 : a1 ~ b1 : A1/R == a2 ~ b2 : A2/R
% G, c:a1 ~ b1 : A1/R ; D |- g3 : B1 ~ (# B2 {{{c/c}}} #) : R'
% B3 = B2 { c |>R' sym g1 / c }
% G |- all c:a1 ~ b1 : A1/R . B1 : TYPE/R'
% [G |- all c:a2 ~ b2 : A2/R . B3 : TYPE/R']
% G |- all c:a1 ~ b1 : A1/R . B2 : TYPE/R'
% ----------------------------------------------------- :: CPiCong
% G ; D |- (all c: g1. g3) : (all c:a1 ~ b1 : A1/R. B1) ~ (all c:a2 ~ b2 : A2/R. B3) : R
%
%
% G ; D |- g1 : b0 ~ b1 : A1/R == b2 ~ b3 : A2/R
% G, c:b0 ~ b1 : A1/R ; D |- g3 : a1 ~ (# a2{{{c/c}}} #) : R'
% a3 = a2 { c |>R' sym g1 / c }
% %% To know that the two types are equal, we need to know
% %% that the range types can be shown identical without using
% %% the assumption c:phi1. This is a stronger property than
% %% regularity implies.
% G |- (/\ c:b0 ~ b1 : A1/R. a1) : all c:b0 ~ b1 : A1/R. B1/R'
% G |- (/\ c:b0 ~ b1 : A1/R. a2) : B/R'
% G |- (/\ c:b2 ~ b3 : A2/R. a3) : all c:b2 ~ b3 : A2/R. B2/R'
% G ; dom G |- g4 : all c:b0 ~ b1 : A1/R. B1 ~ all c:phi2. B2 : R'
% ---------------------------------------------------------------- :: CAbsCong
% G ; D |- (\ c: g1. g3 @ g4) : (/\ c:b0 ~ b1 : A1/R. a1) ~ (/\ c:b2 ~ b3 : A2/R. a3) : R'
%
%
% G ; D |- g1 : a1 ~ b1 : R
% G ; dom G |- g2 : a2 ~ b2 : R'
% G ; dom G |- g3 : a3 ~ b3 : R'
% G |- a1 [g2] : A / R
% G |- b1 [g3] : B / R
% [ G ; dom G |- g4 : A ~ B : R ]
% -------------------------------------- :: CAppCong
% G ; D |- g1 (g2, g3) : a1 [ g2 ]  ~ b1 [ g3 ] : R
%
%
% G ; D |- g1 : (all c1:a~a':A/R. B1) ~ (all c2:b~b':B/R'. B2) : R0
% G ; dom G |- g2 : a~a' : R
% G ; dom G |- g3 : b~b' : R'
% -------------------------------------------------- :: CPiSnd
% G ; D |- g1 @ (g2, g3) : B1 { g2 / c1 } ~ B2 { g3 / c2 } : R0
%
%
% G ; D |- g1 : a~a' : R1
% G ; D |- g2 : a~a' :A/R1 == b~b' : B/R1
% --------------------------------------- :: Cast
% G ; D |- g1 |>R1 g2 : b~b' : R1
%
%
% G ; D |- g : (a~a' : A/R) == (b~b' : B/R)
% ---------------------------------- :: IsoSnd
% G ; D |- isoSnd g : A ~ B : R
%
% G ; D |- g : a ~ b : R1
% R1 <= R2
% ---------------------------------------- :: Sub
% G ; D |- sub g : a ~ b : R2
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
defn
|- G ::      :: AnnCtx :: 'An_'
{{ com context wellformedness }}
by
%
%
% ---------- :: Empty
% |- empty
%
% |- G
% G |- A : TYPE/R
% x notin dom G
% --------------------- :: ConsTm
% |- G, x : A/R
%
% |- G
% G |- phi ok
% c notin dom G
% -------------------- :: ConsCo
% |- G, c:phi
%
% defn
% |- S ::    :: AnnSig :: 'An_Sig_'
% {{ com signature wellformedness }}
% by
%
% ------------ :: Empty
% |- emptyS
%
%
% |- S
% empty |- A : TYPE/R
% empty |- a : A/R
% F notin dom S
% ---------------- :: ConsAx
% |- S, F ~ a  : A/R
%
%
defns
  Jred :: '' ::=

defn
G |- a ~>h b / R ::   :: head_reduction :: 'An_'
{{ com single-step, weak head reduction to
   values for annotated language }}
% NOTE: this reduction needs a context for the the
% two push rules. We need to read the coercion proofs
% to know what type annotations to use after the push.
by
%
% G |- a ~>h a' / R1
% -------------------------  :: AppLeft
% G |- a rho R b ~>h a' rho R b  / R1
%
% Value R (\rho x:A/R.w)
% -----------------------------------------  :: AppAbs
% G |- (\rho x:A/R.w) rho R a ~>h w { a / x} / R
%
%
% G |- a  ~>h a' / R
% -----------------------------   :: CAppLeft
% G |- a [g]  ~>h a' [g] / R
%
%
% ------------------------------------  :: CAppCAbs
% G |- (/\c:phi.b) [g] ~>h b { g / c} / R
%
% G |- A : TYPE/R
% G, x : A/R |- b ~>h b' / R1
% ------------------------------------------- :: AbsTerm
% G |- (\- x:A/R. b) ~>h (\- x:A/R. b') /R1
%
%
% F ~ a : A/R in an_toplevel
% ------------------------- :: Axiom
% G |- F ~>h a / R
%
%
% G |- a ~>h a' / R
% ---------------------------- :: ConvTerm
%  G |- a |>R1 g ~>h a' |>R1 g / R
%
%
% Value R v
% ------------------------------------- :: Combine
% G |- (v |>R2 g1) |>R2 g2 ~>h v |>R2 (g1 ; g2) / R
%
% % Not used (or needed)
%
% %   G ; dom G |- g : all rho x1:A1 -> B1 ~ all rho x2:A2 -> B2
% %   a1 = a { x2 |> sym (piFst g) / x1 }
% %   g2 = g @ refl2 (# x2 |> sym (piFst g) #) x2 (# piFst g #)
% % ------------------------------------------------------------------------- :: Push
% %   G |- ( (\rho x1:A1.a) |> g ) rho b ~>h (\rho x2:A2. (a1 |> g2)) rho b
%
% %   G ; dom G |- g : all c1:phi1. A1 ~ all c2:phi2. A2
% %   a1 = a { c2 |> sym (cpiFst g)  / c1 }
% %   g2 = g @ (c2 |> sym (cpiFst g), c2)
% % ------------------------------------------------------------------ :: CPush
% %   G |- ( (/\c1:phi1.a) |> g ) [g1] ~>h (/\c2:phi2. (a1 |> g2)) [g1]
%
%
%
% Value R v
% G ; dom G |- g : all rho x1: A1/R -> B1 ~ all rho x2: A2/R -> B2 : R'
% b' = b |>R' sym (piFst g)
% g' = g @ refl2 b' b (piFst g)
% ---------------------------------------------------------- :: Push
% G |- (v |>R' g) rho R b ~>h ((v rho R b') |>R' g') / R
%
%
% % Value R v
% % G ; dom G |- g : all c1:a1 ~ b1 : B1/R. A1 ~ all c2:a2 ~ b2 : B2/R. A2 : R'
% % g1' = g1 |>R' sym (cpiFst g)
% % g' = g @ ( g1' , g1 )
% % -------------------------------------------------------- :: CPush
% % G |- (v |>R' g) [g1] ~>h ((v [g1']) |>R' g') / R
% %


defns
 JAlt :: '' ::=

defn  
G |== a : A  ::    :: ATyping :: 'ATyping_'
by
G |= a : A
G ; dom G |= A == B : TYPE / Nom
[ G |= B : TYPE ]
----------------------------- :: Conv
G |== a : B



defn
|== a > b / R  ::     :: ABeta :: 'ABeta_'
{{ com fake rules for the paper }}
by

F : p ~ b : A/R1 @ Rs in toplevel
match a with p -> b +> b'
R1 <= R
-------------------------------------------------------- :: Axiom
|== a > b' / R



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%__ Homs (binders, formatting, etc) __%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: move these in different files

%%%%____ Formatting ____%%%%

%%__ Roles __%%
homs ''
  :: Min      {{ tex [[R1]] \cap [[R2]]              }}

%%__ Role lists __%%
homs ''
  :: nilR     {{ tex \cdot }}

%%__ Constraints __%%
homs ''
  :: Eq       {{ tex [[a]] [[~]]_{[[A]]/[[R]]} [[b]] }}
  :: EqNT     {{ tex [[a]] [[~]]_{[[R]]} [[b]]       }}


%%__ Terms __%%
homs 'a_'
  :: Star     {{ tex \star                                                }}
  :: Var
  :: Abs      {{ tex \mathrm{\lambda}^[[rho]][[x]]\!:\![[A]].[[b]]        }}
  :: UAbs     {{ tex \mathrm{\lambda}^{[[rho]]}[[x]].[[b]]                }}
  :: App      {{ tex [[a]]\ [[b]]^{[[nu]]}                                }}
  :: Pi       {{ tex \mathrm{\Pi}^[[rho]][[x]]\!:\![[A]][[->]][[B]]       }}



  :: CAbs     {{ tex [[/\]][[c]]\!:\![[phi]].[[b]]                        }}
  :: UCAbs    {{ tex [[/\]][[c]].[[b]]                                    }}
  :: CApp
  :: CPi      {{ tex [[all]][[c]]\!:\![[phi]].[[B]]                       }}

  :: Conv     {{ tex [[a]][[|>]]_{[[R]]} [[g]]                            }}

  :: Fam

  :: Bullet

  :: Pattern {{ tex \mathsf{case}_[[R]] \hspace{3pt} [[a]] \hspace{3pt} \mathsf{of} \hspace{3pt} [[F]] \rightarrow [[b1]] \| \_ \rightarrow [[b2]] }}

  :: DataCon
  :: Case

  :: Sub

  :: Subst
  :: SubstC

  :: StdTmSubst     {{ tex [[a]] \lbrace [[b]] [[/]] [[x]]  \rbrace }}
  :: StdCoSubst     {{ tex [[a]] \lbrace [[g]] [[/]] [[c]] \rbrace }}

  %% Hack: when id subst needed to force correct LN output (no shown in tex)
  :: SecretSubst  {{ tex [[a]] }}
  :: SecretSubstC {{ tex [[a]] }}


  :: Paren
  %% Ott parsing precedence is hard
  :: SecretParen {{ tex [[a]] }} {{ com parsing precedence is hard }}

  :: Erase       {{ tex |[[a]]|_{[[R]]} }}

  %% abbreviations for examples
  :: Int
  :: Bool
  :: Nat
  :: Vec
  :: Zero
  :: Succ    {{ tex \mathsf{S} }}
  :: True
  :: Fix
  :: Arrow
  :: CArrow
  :: RelApp  {{ tex [[a]]\ [[b]]                  }}
  :: RelUAbs {{ tex \lambda [[x]].[[a]]           }}
  :: RelAbs  {{ tex \lambda [[x]]\!:\![[A]].[[a]] }}
  :: RelPi


%%__ Coercions __%%
homs 'g_'
  :: Refl2      {{ tex ([[a]]\mathrel{|\!\!=\!\!|}_{[[g]]}[[b]])               }}
  :: PiCong     {{ tex \mathrm{\Pi}^{[[R]],[[rho]]}[[x]]\!:\![[g1]].[[g2]]     }}
  :: AbsCong    {{ tex \mathrm{\lambda}^{[[R]],[[rho]]}[[x]]\!:\![[g1]].[[g2]] }}
  :: AppCong    {{ tex [[g1]]\ [[g2]]^{[[R]],[[rho]]}                          }}
  :: CPiCong    {{ tex [[all]][[c]]\!:\![[g1]].[[g3]]                          }}
  :: CAbsCong   {{ tex \mathrm{\lambda}[[c]]\!:\![[g1]].[[g3]][[@]][[g4]]      }}
  :: CPiSnd     {{ tex [[g]] [[@]] ([[g1]] \sim [[g2]])                        }}
  :: Cast       {{ tex [[g1]] [[|>]]_{[[R]]} [[g2]]                            }}
  :: EqCong     {{ tex [[g1]] [[~]]_{[[A]]} [[g2]]                             }}
  :: IsoConv    {{ tex [[conv]]\ [[phi1]]\sim_[[g]] [[phi2]]                   }}
  :: SecretParen {{ tex [[g]] }}


%%%%____ Coq translation ____%%%%


%%__ Roles __%%
homs ''
  :: Min           {{ coq (min [[R1]][[R2]])                       }}
  :: Param         {{ coq (param[[R1]] [[R2]])                     }}
  :: App           {{ coq (app_role [[nu]])                        }}
  :: RParen        {{ coq ([[R]])                                  }}


%%__ Constraints __%%
homs ''
  :: Paren         {{ coq ([[phi]])                                }}
  :: Subst         {{ coq (open_constraint_wrt_tm [[x b]] [[phi]]) }}
  :: Erase         {{ coq (erase_constraint [[phi]])               }}
  :: EqNT          {{ coq 0                                        }}

%%__ Terms __%%
homs 'a_'
  :: Subst         {{ coq (open_tm_wrt_tm [[x a]] [[b]])           }}
  :: SubstC        {{ coq (open_tm_wrt_co [[c a]] [[g]])           }}

  :: StdTmSubst      {{ coq (tm_subst_tm_tm [[b]] [[x]] [[x a]])     }}
  :: StdCoSubst      {{ coq (co_subst_co_tm [[g]] [[c]] [[c a]])     }}

  %% Hack: when id subst needed to force correct LN output (no shown in tex)
  :: SecretSubst   {{ coq (open_tm_wrt_tm [[x a]] [[b]])           }}
  :: SecretSubstC  {{ coq (open_tm_wrt_co [[c a]] [[g]])           }}


  :: Paren         {{ coq ([[a]])                                  }}
  %% Ott parsing precedence is hard
  :: SecretParen   {{ coq [[a]]                                    }}

  :: Erase         {{ coq (erase_tm [[a]][[R]])                    }}

  %% abbreviations for examples
  :: Int           {{ coq 0                                        }}
  :: Bool          {{ coq 0                                        }}
  :: Nat           {{ coq 0                                        }}
  :: Vec           {{ coq 0                                        }}
  :: Zero          {{ coq 0                                        }}
  :: Succ          {{ coq 0                                        }}
  :: True          {{ coq 0                                        }}
  :: Fix           {{ coq 0                                        }}
  :: Arrow         {{ coq (a_Pi [[a]] [[b]])                       }}
  :: CArrow        {{ coq (a_CPi [[phi]] [[A]])                    }}
  :: RelApp        {{ coq (a_App [[a]] Rel [[b]])                  }}
  :: RelUAbs       {{ coq (a_UAbs Rel Nom [[a]])                   }}
  :: RelAbs        {{ coq (a_Abs Rel [[A]] [[a]])                  }}
  :: RelPi         {{ coq (a_Pi  Rel [[A]] [[B]])                  }}
  :: If            {{ coq 0                                        }}


%%__ Coercions __%%
homs 'g_'
  :: Paren         {{ coq ([[g]])                                  }}
  :: SecretParen   {{ coq [[g]]                                    }}
  :: TSubst        {{ coq open_co_wrt_tm [[x g]] [[a]]             }}



%%%%____ Comments ____%%%%

%%__ Terms __%%
homs 'a_'
  :: SecretParen {{ com parsing precedence is hard }}
