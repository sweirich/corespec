
%% This file uses the Ott tool to specify the grammar, typing and
%% evaluation rules for the implicit and explicit languages

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar tmvar, x, y, f, m, n ::=
  {{ repr-locally-nameless }}
  {{ com variables }}
  {{ lex alphanum }}

metavar covar, c ::=
  {{ repr-locally-nameless }}
  {{ com coercion variables }}
  {{ lex alphanum }}

metavar datacon, K ::= {{ coq atom }}

metavar const, T ::= {{ coq atom }} 
  {{ lex Alphanum }}

metavar tyfam, F ::= {{ coq atom }}
  {{ lex Alphanum }}

indexvar index, i ::=
  {{ tex \mathit{[[index]]} }} {{ com indices }} {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR

grammar

role, R :: '' ::= {{ com Role }}
   | Nom  ::    :: Nom
   | Rep  ::    :: Rep
   | min R1 R2  :: S :: Min
     {{ coq (min [[R1]][[R2]]) }}
     {{ tex [[R1]] \cap [[R2]] }}
   | max R1 R2  :: S :: Max
     {{ coq (max [[R1]][[R2]]) }}
     {{ tex [[R1]] \cup [[R2]] }}


relflag, rho {{ tex \rho }} :: '' ::= {{ com relevance flag }}
   | +             ::   :: Rel
   | -             ::   :: Irrel

constraint, phi {{ tex \phi }} :: '' ::= {{ com props }}
   | a ~ b : A / R   ::   :: Eq
     {{ tex [[a]] [[~]]_{[[A]]/[[R]]} [[b]] }}
   | ( phi )          :: S :: Paren
     {{ coq ([[phi]]) }}
   | phi { b / x }    :: S :: Subst
     {{ coq (open_constraint_wrt_tm [[x b]] [[phi]]) }}
   | | phi |          :: S :: Erase
     {{ coq (erase_constraint [[phi]]) }}


tm, a, b, v, w, A, B :: 'a_' ::= {{ com types and kinds }}
   | TYPE               ::   :: Star
     {{ tex \star }}
   | x                  ::   :: Var
   | \ rho x : A / R . b    ::   :: Abs (+ bind x in b +)
     {{ tex \mathrm{\lambda}^[[rho]][[x]]\!:\![[A]]/[[R]].[[b]] }}
   | \ rho R x . b        ::   :: UAbs (+ bind x in b +)
     {{ tex \mathrm{\lambda}^{[[R]],[[rho]]}[[x]].[[b]] }}
   | a rho R b            ::   :: App
     {{ tex [[a]]\ [[b]]^{[[R]],[[rho]]}  }}
   | F                  ::   :: Fam
   | T                  ::   :: Const
   | all rho x : A / R -> B ::   :: Pi (+ bind x in B +)
     {{ tex \mathrm{\Pi}^[[rho]][[x]]\!:\![[A]]/[[R]][[->]][[B]] }}
   | a |> R g             ::   :: Conv
     {{ tex [[a]][[|>]]_{[[R]]} [[g]] }}
   | all c : phi . B    ::   :: CPi (+ bind c in B +)
     {{ tex [[all]][[c]]\!:\![[phi]].[[B]] }}

   | /\ c : phi . b     ::   :: CAbs (+ bind c in b +)
     {{ tex [[/\]][[c]]\!:\![[phi]].[[b]] }}
   | /\ c  . b          ::   :: UCAbs (+ bind c in b +)
     {{ tex [[/\]][[c]].[[b]] }}
   | a [ g ]            ::   :: CApp
   | []                 ::   :: Bullet

   %% currently unused but ready for extension
   | K                ::   :: DataCon
   | match a with brs ::   :: Case

	%% change the role in an annotated term
   | sub R a          ::    :: Sub

   %% standard substitution, using open
   | a { b / x }      :: S :: Subst
     {{ coq (open_tm_wrt_tm [[x a]] [[b]]) }}

   %% this is a hack for when a substitution {x/x} is necessary for the
   %% locally nameless backend to generate the correct code, but we don't
   %% want this substitution to show in the tex output

   | a {{{ b / x }}}  :: S :: SecretSubst
     {{ coq (open_tm_wrt_tm [[x a]] [[b]]) }}
     {{ tex [[a]] }}

   | a { g / c }      :: S :: SubstC
     {{ coq (open_tm_wrt_co [[c a]] [[g]])  }}
   | a {{{ g / c }}}  :: S :: SecretSubstC
     {{ coq (open_tm_wrt_co [[c a]] [[g]])  }}
     {{ tex [[a]] }}


   | ( a )            :: S :: Paren
     {{ coq ([[a]]) }}
   %% Ott parsing precedence is hard
   | (# a #)          :: S :: SecretParen
     {{ coq [[a]] }} {{ tex [[a]] }}
     {{ com parsing precedence is hard }}

   |  | a | R          :: S :: Erase   {{ coq (erase_tm [[a]][[R]]) }}

   %% abbreviations for examples
   | Int              :: S :: Int    {{ coq 0 }}
   | Bool             :: S :: Bool   {{ coq 0 }}
   | Nat              :: S :: Nat    {{ coq 0 }}
   | Vec              :: S :: Vec    {{ coq 0 }}
   | 0                :: S :: Zero   {{ coq 0 }}
   | Succ             :: S :: Succ   {{ coq 0 }} {{ tex \mathsf{S} }}
   | True             :: S :: True   {{ coq 0 }}
   | Fix              :: S :: Fix    {{ coq 0 }}
   | Age              :: S :: Age    {{ coq 0 }}
   | a -> b           :: S :: Arrow  {{ coq (a_Pi [[a]] [[b]]) }}
   | phi => A         :: S :: CArrow {{ coq (a_CPi [[phi]] [[A]]) }}
   | a R b          :: S :: RelApp
     {{ coq (a_App [[a]] Rel [[R]] [[b]]) }}
     {{ tex [[a]] [[b]]^{[[R]],+} }}
   | \ x R . a          :: S :: RelUAbs
     {{ coq (a_UAbs Rel [[R]] [[a]]) }}
     {{ tex \lambda^{[[R]]} [[x]].[[a]] }}
   | \ x : A / R . a      :: S :: RelAbs
     {{ coq (a_Abs Rel [[A]] [[R]] [[a]]) }}
     {{ tex \lambda [[x]]\!:\![[A]].[[a]] }}
   | all x : A / R -> B   :: S :: RelPi
     {{ coq (a_Pi  Rel [[A]] [[R]] [[B]]) }}

%% Currently unused
brs :: 'br_' ::=    {{ com case branches }}
   | none             ::   :: None
   | K => a ; brs     ::   :: One
   | brs { a / x }    :: S :: Subst  {{ coq (open_brs_wrt_tm [[x brs]] [[a]]) }}
   | brs { g / c }    :: S :: SubstC {{ coq (open_brs_wrt_co [[c brs]] [[g]]) }}
   | ( brs )          :: S :: Paren  {{ coq ([[brs]]) }}

co, g {{ tex \gamma }} :: 'g_' ::= {{ com explicit coercions }}
   | o                    ::   :: Triv
   | c                    ::   :: Var
   | red a b              ::   :: Beta

   | refl a               ::   :: Refl
   | refl2 a b g          ::   :: Refl2
     {{ tex ([[a]]\mathrel{|\!\!=\!\!|}_{[[g]]}[[b]]) }}
   | sym g                ::   :: Sym
   | g1 ; g2              ::   :: Trans
   | sub g                ::   :: Sub

   | all rho R x : g1 -> g2 ::   :: PiCong (+ bind x in g2 +)
     {{ tex \mathrm{\Pi}^{[[R]],[[rho]]}[[x]]\!:\![[g1]].[[g2]] }}

   | \ rho R x : g1 . g2    ::   :: AbsCong (+ bind x in g2 +)
     {{ tex \mathrm{\lambda}^{[[R]],[[rho]]}[[x]]\!:\![[g1]].[[g2]] }}

   | g1 rho R g2            ::   :: AppCong
     {{ tex [[g1]]\ [[g2]]^{[[R]],[[rho]]} }}

   | piFst g              ::   :: PiFst
   | cpiFst g             ::   :: CPiFst
   | isoSnd g            ::   :: IsoSnd
   | g1 @ g2              ::   :: PiSnd

   | all c : g1 . g3      ::   :: CPiCong (+ bind c in g3 +)
     {{ tex [[all]][[c]]\!:\![[g1]].[[g3]] }}

   | \ c : g1 . g3 @ g4   ::   :: CAbsCong (+ bind c in g3 +)
     {{ tex \mathrm{\lambda}[[c]]\!:\![[g1]].[[g3]][[@]][[g4]] }}

   | g ( g1 , g2 )        ::   :: CAppCong
   | g @ ( g1 , g2 )      ::   :: CPiSnd
     {{ tex [[g]] [[@]] ([[g1]] \sim [[g2]]) }}
   | g1 |> R g2           ::   :: Cast
     {{ tex [[g1]] [[|>]]_{[[R]]} [[g2]] }}
   | g1 ~ A  g2       ::   :: EqCong
     {{ tex [[g1]] [[~]]_{[[A]]} [[g2]] }}
   | conv phi1 phi2 g     ::   :: IsoConv
     {{ tex [[conv]]\ [[phi1]]\sim_[[g]] [[phi2]] }}

   | eta a                ::   :: Eta
   | left g g'            ::   :: Left
   | right g g'           ::   :: Right

   | ( g )                :: S :: Paren   {{ coq ([[g]]) }}
   | (# g #)              :: S :: SecretParen
     {{ coq [[g]] }} {{ tex [[g]] }}
   | g { a / x }          :: S :: TSubst
     {{ coq open_co_wrt_tm [[x g]] [[a]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

substitutions
  single a x   :: tm_subst_tm
  single g x   :: co_subst_tm
  single a c   :: tm_subst_co
  single g c   :: co_subst_co
  single brs x :: brs_subst_tm
  single brs c :: brs_subst_co

freevars
  a x   :: fv_tm_tm
  g x   :: fv_co_tm
  a c   :: fv_tm_co
  g c   :: fv_co_co
  brs x :: fv_tm_brs
  brs c :: fv_co_brs

parsing
  a_Abs right a_App
  a_UAbs right a_App
  a_Abs <= a_RelApp
  a_UAbs <= a_RelApp
  a_App left a_App
  a_RelApp left a_App
  a_App left a_RelApp
  a_RelApp left a_RelApp
  a_CApp left a_App
  a_App left a_CApp
  a_CApp left a_RelApp
  a_RelApp left a_CApp

  a_Arrow right a_Arrow
  a_App right a_Arrow
  a_RelApp right a_Arrow
  a_Pi right a_Arrow
  a_CPi right a_Arrow

  a_Arrow <= a_Pi

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  This part is not handled by LNgen

grammar

sig_sort :: '' ::= {{ com signature classifier }}
   | : A            ::    :: Cs
   | ~ a : A / R    ::    :: Ax
   
sort :: '' ::= {{ com binding classifier }}
   | Tm A R           ::   :: Tm
   | Co phi           ::   :: Co

context, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com contexts }}
                                          {{ coq list ( atom * sort ) }}
   | empty           ::    :: Empty   {{ coq nil }}

   | G , x : A / R   ::    :: ConsTm  {{ coq (([[x]]~ Tm [[A]][[R]]) ++ [[G]]) }}
   | G , c : phi     ::    :: ConsCo  {{ coq (([[c]]~ Co [[phi]]) ++ [[G]]) }}

   | G { b / x }     :: M  :: SubstA  {{ coq (open_context_wrt_tm [[x G]][[b]] }}
   | G { g / c }     :: M  :: SubstG  {{ coq (open_context_wrt_co [[c G]][[g]]  }}
   | G ++ G'         :: M  :: Append  {{ coq ([[G]] ++ [[G']]) }}
     {{ tex [[G]], [[G']] }}
   | | G |           :: M  :: Erase   {{ coq (erase_context [[G]]) }}
   | ( G )           :: M  :: Paren   {{ coq ([[G]]) }}
   | (# G #)         :: M  :: SecretParen {{ coq [[G]] }} {{ tex [[G]] }}

sig, S {{ tex \Sigma }} :: 'sig_' ::= {{ com signatures }} {{ coq list (atom * sig_sort) }}
   | emptyS         ::    :: Empty       {{ coq nil }}
     {{ tex \varnothing }}
   | S , F sig_sort    ::    :: ConsAx      {{ coq (([[F]]~ [[sig_sort]])++[[S]]) }}
   | toplevel        :: M  :: Toplevel
     {{ coq toplevel }}
     {{ tex \Sigma_0 }}
   | an_toplevel    :: M  :: AnToplevel
     {{ coq an_toplevel }}
     {{ tex \Sigma_1 }}
   | | S |          :: M  :: Erase  {{ coq (erase_sig [[S]]) }}

available_props, D {{ tex \Delta }} :: 'D_' ::= {{ coq atoms }} {{ coq-universe Type }}
   | emptyD          ::    :: Empty   {{ coq AtomSetImpl.empty }} {{ tex \varnothing }}
   | D , c           ::    :: ConsCo  {{ coq (singleton [[c]] \u [[D]]) }}
   | dom G           :: M  :: DomG    {{ coq (dom [[G]]) }} {{ tex \widetilde {[[G]]} }}
   | ( D )           :: M  :: Paren   {{ coq ([[D]]) }}
   
role_context, W {{ tex \Omega }} :: 'rctx_' ::= {{ com role_contexts }}
                                          {{ coq list ( atom * role ) }}
   | empty           ::    :: Empty   {{ coq nil }}
   | W , x : R       ::    :: ConsTm  {{ coq (([[x]] ~ [[R]]) ++ [[W]]) }}
   | ( W )           :: M  :: Paren   {{ coq ([[W]]) }}
   | (# W #)         :: M  :: SecretParen {{ coq [[W]] }} {{ tex [[W]] }}


substitutions
  single G x :: ctx_subst_tm
  single G c :: ctx_subst_co

freevars
  G x :: fv_ctx_tm
  G c :: fv_ctx_co
  W x :: fv_rctx_tm



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Terminals  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

terminals :: 'terminals_' ::=
  | <->               ::   :: iso           {{ tex \leftrightarrow }}
  | <=>               ::   :: lrarrow       {{ tex \Leftrightarrow }}
  | -->               ::   :: step          {{ tex \longrightarrow }}
  | min               ::   :: min           {{ tex \mathsf{min} }}
  | ==                ::   :: definitional  {{ tex \equiv }}
  | all               ::   :: forall     {{ tex \forall }}
  | in                ::   :: in         {{ tex \in }}
  | notin             ::   :: notin      {{ tex \not\in }}
  | <=                ::   :: check      {{ tex \Leftarrow }}
  | =>                ::   :: infer      {{ tex \Rightarrow }}
  | =>*               ::   :: minfer      {{ tex \Rightarrow^{\ast} }}
  | ->                ::   :: arrow      {{ tex \to }}
  | /\                ::   :: ilam       {{ tex \mathrm{\Lambda} }}   % Swag
  | <-|               ::   :: mapsfrom   {{ tex \mapsfrom }}
  | []                ::   :: box        {{ tex \Box }}
  | |-                ::   :: entails    {{ tex \vdash }}
  | -|                ::   :: produces   {{ tex \dashv }}
  | |=                ::   :: hs_entails {{ tex \vDash }}
  | |==               ::   :: hs_entaill {{ tex \vDash }}
  | /=                ::   :: neq        {{ tex \neq }}
  | |>                ::   :: cast       {{ tex \triangleright }}
  | ok                ::   :: ok         {{ tex \ \mathsf{ok} }}
  | _                 ::   :: blank      {{ tex \_ }}
  | ~>                ::   :: produce    {{ tex \leadsto }}
  | ~>*               ::   :: multistep  {{ tex \leadsto^{\ast} }}
  | ~>h               ::   :: steph      {{ tex \leadsto }}
  | empty             ::   :: empty      {{ tex \varnothing }}
  | hole              ::   :: hole       {{ tex \circ }}
  | fv                ::   :: fv         {{ tex \mathsf{fv}\! }}
  | dom               ::   :: dom        {{ tex \mathsf{dom} }}
  | ~                 ::   :: twiddle    {{ tex \sim }}
  | ~~                ::   :: compatible {{ tex \asymp }}
  | '|'               ::   :: bar        {{ tex | }}
  | o                 ::   :: bullet     {{ tex \bullet }}
  | fst               ::   :: fst
  | snd               ::   :: snd
  | |=>|              ::   :: erasesto   {{ tex \mathrel{|\Rightarrow|} }}
  | |-=               ::   :: turneq     {{ tex \vdash_{=} }}
  | refl2             ::   :: refl2      {{ tex \mathbf{refl_2}  }}
  | ++                ::   :: concat     {{ tex \mathop{++} }}

formula, Fm {{tex \psi}} :: 'formula_' ::=
  | judgement                ::   :: judgement
  | x : A / R in G               ::   :: inG
    {{ coq binds [[x]] (Tm [[A]][[R]]) [[G]] }}
  | x : R in W               ::   :: inW
    {{ coq binds [[x]] [[R]] [[W]] }}

  | c : phi  in G         ::   :: inGP
    {{ coq binds [[c]] (Co [[phi]]) [[G]] }}

  | T : A / R in S             ::   :: inGF
    {{ coq binds [[T]] (Cs [[A]] [[R]]) [[S]] }}

  | F ~ a : A / R in S             ::   :: inGFam
    {{ coq binds [[F]] (Ax [[a]][[A]][[R]]) [[S]] }}

  | K : T G in S               ::   :: inSD
    {{ coq binds [[K]] ([[T]],[[G]]) [[S]] }}

  | x in D                   ::   :: availx
    {{ coq AtomSetImpl.In [[x]] [[D]] }}
  | c in D                   ::   :: avail
    {{ coq AtomSetImpl.In [[c]] [[D]] }}
  | c not relevant in g      ::   :: notrelevant
    {{ coq [[c]] \notin (fv_relevant [[g]]) }}
  | x notin fv a             ::   :: fresh
    {{ coq [[x]] \notin fv_tm_tm_tm [[a]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
  | rctx_uniq W              ::   :: uniqWx
    {{ coq uniq [[W]] }}
  | c notin dom G            ::   :: notInGc
    {{ coq ~ AtomSetImpl.In [[c]] (dom [[G]]) }}
  | T notin dom S            ::   :: notInST
    {{ coq ~ AtomSetImpl.In [[T]] (dom [[S]]) }}
  | F notin dom S            ::   :: notInSF
    {{ coq ~ AtomSetImpl.In [[F]] (dom [[S]]) }}
  | a = b                    ::   :: equal
    {{ coq ([[a]] = [[b]]) }}
  |  phi1 =  phi2       ::   :: erasedphi
    {{ coq ([[phi1]] = [[phi2]]) }}
  | G1 = G2                  ::   :: equalctx
    {{ coq ([[G1]] = [[G2]]) }}
  | g1 = g2                  ::   :: equalco
    {{ coq ([[g1]] = [[g2]]) }}
  | not Fm              ::   :: not
    {{ coq not ([[Fm]]) }}
    {{ tex \neg [[Fm]] }}
  | Fm1 /\ Fm2     ::   :: and
    {{ coq [[Fm1]] /\ [[Fm2]] }}
    {{ tex [[Fm1]] \wedge [[Fm2]] }}
  | Fm1 \/ Fm2     ::   :: or
    {{ coq [[Fm1]] \/ [[Fm2]] }}
    {{ tex [[Fm1]] \vee [[Fm2]] }}
  | Fm1 implies Fm2     ::   :: implies
    {{ coq [[Fm1]] -> [[Fm2]] }}
    {{ tex [[Fm1]] \Rightarrow [[Fm2]] }}
  | ( Fm )              ::   :: Paren
    {{ coq ([[Fm]]) }}
  | [ Fm ]              ::   :: Regular
    {{ coq ([[Fm]]) }}
    {{ tex \suppress{[[Fm]]} }}
  | c : (a : A ~ b : B) in G ::   :: Alt
    {{ coq True }}
  | nolc A                   ::   :: NoLC
    {{ com suppress lc hypothesis generated by Ott }}
    {{ coq True }}
	 {{ tex      }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Coq Definitions necessary to specify the semantics

embed {{ coq

Definition min (r1 : role) (r2 : role) : role :=
  match r1 , r2 with
  | Nom, _ => Nom
  | _  , Nom => Nom
  | Rep, Rep => Rep
  end.

Definition max R1 R2 :=
  match R1, R2 with 
    | Rep, _ => Rep 
    | Nom, Rep => Rep 
    | Nom, Nom => Nom
  end.


Definition lte_role (r1 : role) (r2 : role) : bool :=
  match r1 , r2 with
  | Nom, _ => true
  | Rep, Rep => true
  | Rep, Nom => false
  end.

Fixpoint erase_tm (a : tm) (r : role) : tm :=
   match a with
   | a_Star    => a_Star
   | a_Var_b n => a_Var_b n
   | a_Var_f x => a_Var_f x
   | a_Abs rho A R b => a_UAbs rho R (erase_tm b r)
   | a_UAbs rho R b => a_UAbs rho R (erase_tm b r)
   | a_App a Rel R b => a_App (erase_tm a r) Rel R (erase_tm b R)
   | a_App a Irrel R b => a_App (erase_tm a r) Irrel R a_Bullet
   | a_Const T => a_Const T
   | a_Fam F => a_Fam F
   | a_Pi rho A R B => a_Pi rho (erase_tm A R) R (erase_tm B r)
   | a_Conv a r1 g => if (lte_role r1 r) then
	                      erase_tm a r else
						   a_Conv (erase_tm a r) r1 g_Triv
   | a_CPi phi B => a_CPi (erase_constraint phi r) (erase_tm B r)
   | a_CAbs phi b => a_UCAbs (erase_tm b r)
   | a_UCAbs b => a_UCAbs (erase_tm b r)
   | a_CApp a g => a_CApp (erase_tm a r) g_Triv
   | a_DataCon K => a_Star  (* a_DataCon K *)
   | a_Case a brs => a_Star (* a_Case (erase_tm a) (erase_brs brs) *)
   | a_Bullet => a_Bullet
   | a_Sub _ a => erase_tm a r
   end
with erase_brs (x : brs) (r:role): brs :=
   match x with
   | br_None => br_None
   | br_One k a y => br_One k (erase_tm a r) (erase_brs y r)
   end
with erase_constraint (phi : constraint) (r:role): constraint :=
   match phi with
   | Eq A B A1 R => Eq (erase_tm A R) (erase_tm B R) (erase_tm A1 R) R
   end.

Definition erase_sort s r :=
 match s with
 | Tm a R => Tm (erase_tm a r) R
 | Co p => Co (erase_constraint p r)
end.


Definition erase_csort s r :=
 match s with
 | Cs a   => Cs (erase_tm a r)
 | Ax a A R => Ax (erase_tm a r) (erase_tm A r) R
end.

Definition erase_context G r := map (fun s => erase_sort s r) G.
Definition erase_sig S r := map (fun s => erase_csort s r) S.

(* -------------- A specific signature with Fix ------------ *)
Definition Fix : atom.
  pick fresh F.
  exact F.
Qed.

Definition FixDef : tm :=
  (a_Abs Irrel a_Star Nom
         (a_Abs Rel (a_Pi Rel (a_Var_b 0) Nom (a_Var_b 1)) Nom
                (a_App (a_Var_b 0) Rel Nom
                       (a_App (a_App (a_Fam Fix) Irrel Nom (a_Var_b 1)) Rel Nom (a_Var_b 0))))).

Definition FixTy : tm :=
  a_Pi Irrel a_Star Nom
       (a_Pi Rel (a_Pi Rel (a_Var_b 0) Nom (a_Var_b 1)) Nom
             (a_Var_b 1)).


Definition an_toplevel : sig := Fix ~ Ax FixDef FixTy Nom.

Definition toplevel : sig := erase_sig an_toplevel Nom.

Fixpoint ctx_to_rctx (G : context) : role_context :=
  match G with
  | nil => nil
  | (x, (Tm A R)) :: G => (x, R) :: (ctx_to_rctx G)
  | (c, (Co _)) :: G => ctx_to_rctx G
  end.

}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% "Syntactic" definitions

defns
JSubRole :: '' ::=

defn
R1 <= R2  ::  :: SubRole :: ''
{{ com Subroling judgement }}
{{ tex [[R1]] \leq [[R2]] }}
by

------------ :: NomRep
Nom <= Rep


------------ :: Refl
R <= R

R1 <= R2
R2 <= R3
--------- :: Trans
R1 <= R3


defns
   JPath :: '' ::=
   
defn
Path F a R  ::  :: Path :: 'Path_'
{{ com Type headed by constant (partial function) }}
{{ tex \mathsf{Path}_{[[R]]} [[a]] = [[F]] }}
by

F ~ a : A/R1 in toplevel
not (R1 <= R)
-------------------------- :: Const
Path F F R

Path F a R
------------------------ :: App
Path F (a rho R1 b') R

Path F a R
----------------  :: CApp
Path F (a [o]) R

Path F a R
---------------------  :: Conv
Path F (a |>R1 o) R

defns
JValue :: '' ::=

defn
CoercedValue R A ::   :: CoercedValue :: ''
{{ com Values with at most one coercion at the top }}
{{ tex \suppress{\mathsf{CoercedValue}_{[[R]]}\ [[A]]} }}
by

Value R a
----------------- :: CV
CoercedValue R a

Value Nom a
----------------------------- :: CC
CoercedValue Nom (a |>Rep o)

defn
Value R A  ::   :: Value    :: 'Value_'
{{ com values }}
{{ tex \suppress{\mathsf{Value}_{[[R]]}\ [[A]]} }}
by

------- :: Star
Value R TYPE

-------------------------- :: Pi
Value R all rho x : A / R1 -> B

-------------------- :: CPi
Value R all c : phi. B

--------------------- :: AbsRel
Value R \ + x:A/R1. a

--------------------- :: UAbsRel
Value R \ + R1 x. a

CoercedValue R a
--------------------- :: UAbsIrrel
Value R \ - R1 x. a

--------------------- :: CAbs
Value R /\c:phi.a

--------------------- :: UCAbs
Value R /\c .a

F ~ a : A/R1 in toplevel
not (R1 <= R)
------------------------- :: Ax
Value R F

Path F a R
Value R a
--------------------- :: App
Value R (a rho R1 b')

Path F a R
Value R a
--------------------- :: CApp
Value R (a [o])

defn
ValueType R A ::   :: value_type :: 'value_type_'
{{ com Types with head forms (erased language) }}
{{ tex \suppress{\mathsf{ValueType}_{[[R]]}\ [[A]]} }}
by

------- :: Star
ValueType R TYPE

-------------------------- :: Pi
ValueType R all rho x : A / R1 -> B

-------------------- :: CPi
ValueType R all c : phi. B

Path F A R
Value R A 
------------------------ :: Path
ValueType R A


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Definitions for consistency proof

defns
   Jconsistent :: '' ::=

defn
   consistent a b R ::  :: consistent :: 'consistent_a_'
   {{ com (erased) types do not differ in their heads }}
  {{ tex \suppress{\mathsf{consistent}_{[[R]]}\ [[a]] [[b]] } }}
by

---------------------- :: Star
consistent TYPE TYPE R

------------------------ :: Pi
consistent (all rho x1:A1 / R -> B1) (all rho x2:A2 / R -> B2) R'

------------------------ :: CPi
consistent (all c1:phi1. A1) (all c2 :phi2. A2) R

Path F a1 R
Path F a2 R
------------------- :: Path
consistent a1 a2 R

not ValueType R b
---------------------- :: Step_R
consistent a b R

not ValueType R a
---------------------- :: Step_L
consistent a b R

defns
  Jerased :: '' ::=

defn
  W |- erased_tm a R ::  :: erased_tm :: 'erased_a_'
  {{ tex [[W]] \vDash [[a]] : [[R]] }}
by
rctx_uniq W
------------------- :: Bullet
W |- erased_tm [] R

rctx_uniq W
---------------------  :: Star
W |- erased_tm TYPE R

rctx_uniq W
x : R in W
R <= R1
------------------------------- :: Var
W |- erased_tm x R1

W , x : R1 |- erased_tm a R
------------------------------------ :: Abs
W |- erased_tm (\rho R1 x.a) R

%% Note, this is not quite right, but it is ok.
W |- erased_tm a R
W |- erased_tm b R1 
----------------------------- :: App
W |- erased_tm (a rho R1 b) R

W |- erased_tm A R1
W , x : R1 |- erased_tm B R
---------------------------------------- :: Pi
W |- erased_tm (all rho x:A / R1 -> B) R

W |- erased_tm a R1
W |- erased_tm b R1
W |- erased_tm A R1
W |- erased_tm B R
----------------------------------------------- :: CPi
W |- erased_tm (all c:a ~ b : A / R1. B) R

W |- erased_tm b R
---------------------------------- :: CAbs
W |- erased_tm (/\c. b) R

W |- erased_tm a R
------------------------- :: CApp
W |- erased_tm (a [o]) R

rctx_uniq W
F ~ a : A / R in toplevel
--------------------------- :: Fam
W |- erased_tm F R1

rctx_uniq W
------------------- :: Const
W |- erased_tm T R

W |- erased_tm a R
---------------------------- :: TyCast
W |- erased_tm (a |> R1 o) R

defns
JChk :: '' ::=

defn
rho => check x in A ::    :: RhoCheck :: 'Rho_'
{{ tex ([[rho]] = +) \vee ([[x]]\not\in\mathsf{fv}\; [[A]]) }}
{{ com irrelevant argument check }}
by

nolc A
-------------------- :: Rel
+ => check x in A

x notin fv A
-------------------- :: IrrRel
- => check x in A


defns
  Jpar :: '' ::=


defn
 W |- a => b / R ::  :: Par :: 'Par_'
{{ tex [[W]] \vDash [[a]] [[=>]]_{[[R]]} [[b]] }}
{{ com parallel reduction (implicit language) }}
by
W |- erased_tm a R
------------------------- :: Refl
W |- a => a  / R


W |- a => (\rho R1 x.a') / R
W |- b => b' / R1
---------------------------------------- :: Beta
W |- a rho R1 b => a' { b' / x } / R

W |- a => a' / R
W |- b => b' / R1
------------------------------------------- :: App
W |- a rho R1 b => a' rho R1 b' / R

W |- a => (/\c .a')  / R
----------------------- :: CBeta
W |- a [o] => a' { o / c } / R

W |- a => a' / R
----------------------- :: CApp
W |- a [o] => a' [o] / R

W , x : R1 |- a => a' / R
---------------------------------------------------- :: Abs
W |- \ rho R1 x. a => \ rho R1 x. a' / R

W |- A => A' / R1
W , x : R1 |- B => B' / R
--------------------------------------------------------- :: Pi
W |- all rho x:A/R1 -> B => all rho x:A'/R1 -> B' / R

W |- a => a' / R
------------------------------------------ :: CAbs
W |- /\c . a => /\c . a' / R

W |- A => A' / R1
W |- a => a' / R1
W |- b => b' / R1
W |- B => B' / R
------------------------------------------------------------------ :: CPi
W |- all c:a~b:A/R1. B => all c:a'~b':A'/R1. B' / R

% NOTE: toplevel is assumed to be locally closed
F ~ a : A/R1 in toplevel
R1 <= R
rctx_uniq W
-------------------------------- :: Axiom
W |- F => a / R


W |- a1 => a2 / R1
--------------------------------------- :: Cong
W |- a1 |> R o => a2 |> R o / R1


W |- a1 => (a2 |> Rep o)  / Nom
------------------------------------  :: Combine
W |- (a1 |> Rep o) => (a2 |> Rep o) / Nom


W |- a1 => (a2 |> Rep o) / Nom
W |- b1 => b2 / Nom
---------------------------------------------------- :: Push
W |- a1 Nom b1 => (a2 Nom (b2 |> Rep o)) |> Rep o / Nom

W |- a1 => (a2 |> Rep o) / Nom
W |- b1 => b2 / Rep
---------------------------------------------------- :: PushDrop
W |- a1 Rep b1 => (a2 Rep b2) |> Rep o / Nom

W |- a1 => (a2 |> Rep o) / Nom
W |- b1 => (b2 |> Rep o) / Nom
---------------------------------------------------- :: PushCombine
W |- a1 Nom b1 => (a2 Nom (b2 |> Rep o)) |> Rep o / Nom

W |- a1 => (a2 |> Rep o) / Nom
---------------------------------------------------- :: CPush
W |- a1 [o] => (a2 [o]) |> Rep o / Nom


defn
W |- a =>* b / R ::   :: MultiPar :: 'MP_'
{{ tex [[W]] [[|-]] [[a]] [[=>*]]_[[R]] [[b]] }}
{{ com multistep parallel reduction }}
by

------------------------- :: Refl
W |- a =>* a / R

W |- a => b / R
W |- b =>* a' / R
-------------------------- :: Step
W |- a =>* a' / R

defn
W |- a <=> b / R ::   :: joins :: ''
{{ tex [[W]] [[|-]] [[a]] [[<=>]]_[[R]] [[b]] }}
{{ com parallel reduction to a common term }}
by

W |- a1 =>* b / R
W |- a2 =>* b / R
-------------------------- :: join
W |- a1 <=> a2 / R


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implicit (or erased) language reductions

defns
 Jbeta :: '' ::=

defn
|= a > b / R  ::     :: Beta :: 'Beta_'
{{ com primitive reductions on erased terms }}
by

Value R1 (\rho R x. v)
------------------------------------ :: AppAbs
|= (\rho R x.v) rho R b > v { b / x } / R1


------------------------------- :: CAppCAbs
|= (/\c .a') [o] > a' { o / c } / R


F ~ a : A/R in toplevel
-------------------------------- :: Axiom
|= F > a / R

R1 <= R
---------------------- :: Drop
|= v |> R1 o > v / R

CoercedValue Nom (v |> Rep o)
--------------------------------------------- :: Combine
|= (v |> Rep o) |> Rep o > v |> Rep o / Nom

CoercedValue Nom (v1 |> Rep o)
------------------------------------ :: Push
|= (v1 |> Rep o) rho R1 b > (v1 rho R1 (b |> Rep o)) |> Rep o / Nom


CoercedValue Nom (v1 |> Rep o)
------------------------------------ :: CPush
|= (v1 |> Rep o) [o] > (v1 [o]) |> Rep o / Nom

defn
 |= a ~> b / R ::   :: reduction_in_one :: 'E_'
{{ com single-step head reduction for implicit language }}
by

|= a > b / R 
---------------- :: Prim
|= a ~> b / R

|= a ~> a' / R1
-------------------------  :: AbsTerm
|= \- R x.a ~> \- R x.a' / R1

|= a ~> a' / R1
-------------------------  :: AppLeft
|= a rho R b ~> a' rho R b / R1

|= a  ~> a' / R
-----------------------------   :: CAppLeft
|= a [o]  ~> a' [o] / R


|= a ~> a' / R1
------------------------------- :: Cong
|= a |> R o ~> a' |> R o / R1


defn

|= a ~>* b / R ::  :: reduction :: ''
{{ com multistep reduction }}
by

------------------- :: Equal
|= a ~>* a / R

|= a ~> b / R
|= b ~>* a' / R
------------------- :: Step
|= a ~>* a' / R

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implicit (or erased) language type system

defns
Jett :: '' ::=


defn
G |= phi ok ::    :: PropWff :: 'E_'
{{ com Prop wellformedness }}
by

G |= a : A / R
G |= b : A / R
[ G |= A : TYPE / R ]
---------------------------  :: Wff
G |= a ~ b : A / R  ok

defn

G |= a : A / R ::   :: Typing :: 'E_'
{{ com typing }}
by

R1 <= R2
G |= a : A / R1
----------------- :: SubRole
G |= a : A / R2

|= G
---------------------  :: Star
G |= TYPE : TYPE / R

|= G
x:A / R in G
------------------ :: Var
G |= x : A / R


G, x:A / R |= B : TYPE / R'
G |= A : TYPE / R 
----------------------------------------- :: Pi
G |= all rho x:A / R -> B : TYPE / R'

G, x:A / R |= a : B / R'
G |= A : TYPE / R 
rho => check x in a
---------------------------------- :: Abs
G |= \ rho R x . a : ( all rho x:A / R -> B ) / R'

G |= b : all+ x : A / R -> B / R'
G |= a : A / R 
------------------------------------- :: App
G |= b + R a : B { a / x } / R'

G |= b : all - x : A / R -> B / R'
G |= a : A / R 
------------------------------------- :: IApp
G |= b - R [] : B { a / x } / R'


G |= a : A / R
G ; dom G |= A == B : TYPE / R
[ G |= B : TYPE / R ]
----------------------------- :: Conv
G |= a : B / R

G, c : phi |= B : TYPE / R
[ G |= phi ok ]
-------------------------------- :: CPi
G |= all c:phi. B : TYPE / R

G, c:phi |= a : B / R
[ G |= phi ok ]
------------------------------------------------- :: CAbs
G |= /\ c . a : all c:phi. B / R

G |= a1 : all c : (a ~ b : A / R) . B1 / R'
G ; dom G |= a == b : A / R
------------------------------------------- :: CApp
G |= a1 [ o ] : B1 { o / c } / R'

|= G
F ~ a : A / R in toplevel
 empty |= A : TYPE / R1 
------------------ :: Fam
G |= F : A / R1

G |= a : A1 / R1
G ; dom G |= A1 == A2 : TYPE / R2
[ G |= A2 : TYPE / R1 ]
------------------------- :: TyCast
G |= a |> R2 o : A2 / R1


defn
G ; D |= phi1 == phi2  ::    :: Iso :: 'E_'
{{ com prop equality }}
by

G ; D |= A1 == A2 : A / R
G ; D |= B1 == B2 : A / R
--------------------------------------------- :: PropCong
G ; D |= A1 ~ B1 : A / R == A2 ~ B2 : A / R

G ; D |= A == B : TYPE / R
G |= A1 ~ A2 : A / R ok
G |= A1 ~ A2 : B / R ok
-------------------------------------------- :: IsoConv
G ; D |= A1 ~ A2 : A / R == A1 ~ A2 : B / R

G ; D |= all c:(a1 ~ a2 : A/R1). B1 == all c:(b1 ~ b2 : B/R2). B2 : TYPE / R'
---------------------------------------------------------------------------- :: CPiFst
G ; D |=  a1 ~ a2 : A/R1 == b1 ~ b2 : B/R2


defn

G ; D |= a == b : A / R ::     :: DefEq :: 'E_'
{{ com definitional equality }}
by

|= G
c: (a ~ b : A / R ) in G
c in D
-------------------- :: Assn
G ; D |= a == b : A / R

G |= a : A / R
------------------------ :: Refl
G ; D |= a == a : A / R

G ; D |= b == a : A / R
------------------------ :: Sym
G ; D |= a == b : A / R

G ; D |= a == a1 : A / R
G ; D |= a1 == b : A / R
------------------------------------- :: Trans
G ; D |= a == b : A / R

G ; D |= a == b : A / R1
R1 <= R2
---------------------------------------- :: Sub
G ; D |= a == b : A / R2

G |= a1 : B / R
[G |= a2 : B / R ]
|= a1 > a2 / R
--------------------------------  :: Beta
G ; D |= a1 == a2 : B / R

%% Rules related to functions

G ; D |=  A1 == A2 : TYPE/R
G, x:A1/R; D |= B1 == B2 : TYPE/R'
%% this needed by weakening IH
[G |= A1 : TYPE/ R ]
%% these two needed by regularity
[G |= all rho x:A1/R -> B1 : TYPE/R']
[G |= all rho x:A2/R -> B2 : TYPE/R']
---------------------------------------------------------- :: PiCong
G ; D |= (all rho x:A1/R -> B1) == (all rho x:A2/R -> B2) : TYPE/R'


G, x:A1/R ; D |= b1 == b2 : B/R'
[ G |= A1 : TYPE/R ]
rho => check x in b1
rho => check x in b2
-------------------------------------------------------------- :: AbsCong
G ; D |=  (\ rho R x. b1) == (\ rho R x. b2) : (all rho x:A1/R -> B)/R'

G ; D |= a1 == b1 : (all + x:A/R -> B)/R'
G ; D |= a2 == b2 : A/R 
-------------------------------------- :: AppCong
G ; D |= a1 + R a2 == b1 + R b2 : (B { a2 / x })/R'


G ; D |= a1 == b1 : (all - x:A/R -> B)/R'
G |= a : A/ R
------------------------------------------ :: IAppCong
G ; D |= a1 - R [] == b1 - R [] : (B { a / x })/R'


G ; D |= all rho x:A1/R -> B1 == all rho x:A2/R -> B2 : TYPE/R'
------------------------------------------------- :: PiFst
G ; D |=  A1 == A2 : TYPE/ R

G ; D |= all rho x:A1/R -> B1 == all rho x:A2/R -> B2 : TYPE/R'
G ; D |= a1 == a2 : A1/R
------------------------------------------- :: PiSnd
G ; D |=  B1 {a1 /x}  == B2 {a2/x} : TYPE/R'

%% Rules related to Coercion Abstraction

G ; D |= a1 ~ b1 : A1/R == a2 ~ b2 : A2/R
G, c: a1 ~ b1 : A1/R ; D |= A == B : TYPE/R'
[G |= a1 ~ b1 : A1/R ok]
[G |= all c: a1 ~ b1 : A1/R. A : TYPE/R']
[G |= all c: a2 ~ b2 : A2/R. B : TYPE/R']
--------------------------------------------------------------------- :: CPiCong
G ; D |= all c: a1 ~ b1 : A1/R . A  == all c: a2 ~ b2 : A2/R . B : TYPE/R'

G, c: phi1 ; D |= a == b : B/R
[ G |= phi1 ok ]
------------------------------------------------------------ :: CAbsCong
G ; D |=  (/\c . a) == (/\ c . b) : all c:phi1. B/R

G ; D |= a1 == b1 : (all c:(a ~ b : A/R). B)/R'
G ; dom G |= a == b : A/R
-------------------------------------- :: CAppCong
G ; D |= a1 [o] == b1 [o] : (B { o / c })/R'

G ; D |= all c:(a1 ~ a2 : A/R). B1 == all c:(a1'~ a2' : A'/R'). B2 : TYPE/R0
G ; dom G |= a1 == a2 : A/R
G ; dom G |= a1' == a2' : A'/R'
---------------------------------------------- :: CPiSnd
G ; D |=  B1 { o / c} == B2 { o / c } : TYPE/R0

%% Other rules

G ; D |= a == b : A/R
G ; D |= a ~ b : A/R == a' ~ b' : A'/R'
-------------------------------------- :: Cast
G ; D |= a' == b' : A'/R'

G ; D |= a == b : A/R1
G ; dom G |= A == B : TYPE/R2
[ R1 <= R2 ]
-------------------------------------- :: EqConv
G ; D |= a == b : B/R2

G ; D |= a ~ b : A/R == a' ~ b' : A'/R
-------------------------------------- :: IsoSnd
G ; D |= A == A' : TYPE/R

G ; D |= a1 == a2 : A / R1
G ; dom G |= A == B : TYPE /R2
G |= B : TYPE / R1
------------------------------------ :: CastCong
G ; D |= a1 |> R2 o == a2 |> R2 o : B / R1

defn
|= G ::    :: Ctx  :: 'E_'
{{ com context wellformedness }}
by

---------- :: Empty
|= empty

|= G
G |= A : TYPE / R
x notin dom G
--------------------- :: ConsTm
|= G, x : A / R

|= G
G |= phi ok
c notin dom G
-------------------- :: ConsCo
|= G, c: phi

defns

Jsig :: '' ::=

defn
|= S ::    :: Sig :: 'Sig_'
{{ com signature wellformedness }}
by

------------ :: Empty
|= emptyS

|= S
empty |= A : TYPE/R
empty |= a : A/R'
F notin dom S
[R' <= R]
---------------- :: ConsAx
|= S, F ~ a : A/R'

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Annotated language semantics
%

defns
Jann :: '' ::=

defn
G |- phi ok ::   :: AnnPropWff :: 'An_'
{{ com prop wellformedness }}
by

G |- a : A/R
G |- b : B/R
|A|R = |B|R
------------------------- :: Wff
G |- a ~ b : A/R  ok

defn
G |- a : A / R ::  :: AnnTyping :: 'An_'
{{ com typing }}
by

|- G
------------  :: Star
G |- TYPE : TYPE/R

|- G
x : A/R in G
----------- :: Var
G |- x : A/R

G, x:A/R |- B : TYPE/R'
[ G |- A : TYPE/R ]
------------------------------------ :: Pi
G |- all rho x:A/R -> B : TYPE/R'

[ G |- A : TYPE/R ]
G, x:A/R |- a : B/R'
rho => check x in | a |R'
R <= R'
---------------------------------- :: Abs
G |- \ rho x : A/R. a : (all rho x:A/R -> B)/R'

G |- b : (all rho x:A/R -> B)/R'
G |- a : A/R
------------------------------------- :: App
G |- b rho R a : (B { a / x })/R'

G |- a : A/R
G ; dom G |- g : A ~ B : R
G |- B : TYPE/R
----------------------------- :: Conv
G |- a |>R g : B/R

[ G |- phi ok ]
G, c : phi |- B : TYPE/R
-------------------------------- :: CPi
G |- all c:phi. B : TYPE/R

[ G |- phi ok ]
G, c:phi |- a : B/R
------------------------------------------------- :: CAbs
G |- /\ c: phi. a : (all c:phi. B)/R

G |- a1 : (all c : a ~ b : A1/R. B)/ R'
G ; dom G |- g : a ~ b : R
------------------------------------- :: CApp
G |- a1 [ g ] : B { g / c } / R'

|- G
F ~ a : A/R in an_toplevel
[ empty |- A : TYPE/R ]
----------------------- :: Fam
G |- F : A/R

R1 <= R2
G |- a : A / R1
----------------- :: SubRole
G |- sub R1 a : A / R2


defn
G ; D |- g : phi1 == phi2 ::  :: AnnIso :: 'An_'
{{ tex [[G]];[[D]][[|-]] [[g]] : [[phi1]] \sim [[phi2]] }}
{{ com coercion between props }}
by

G ; D |- g1 : A1 ~ A2 : R
G ; D |- g2 : B1 ~ B2 : R
G |- A1 ~ B1 : A/R ok
G |- A2 ~ B2 : A/R ok
------------------------------------------------------------ :: PropCong
G ; D |- (g1 ~A g2) : (A1 ~ B1 : A/R) == (A2 ~ B2 : A/R)

G ; D |- g : all c:phi1. A2 ~ all c:phi2. B2 : R
--------------------------------------- :: CPiFst
G ; D |- cpiFst g : phi1 == phi2

G ; D |- g : phi1 == phi2
---------------------------- :: IsoSym
G ; D |- sym g : phi2 == phi1

G; D |- g : A ~ B : R
G |- a1 ~ a2 : A/R ok
G |- a1' ~ a2' : B/R ok
|a1|R = |a1'|R
|a2|R = |a2'|R
-------------------------------------- :: IsoConv
G ; D |- conv (a1 ~ a2 : A/R) (a1' ~ a2' : B/R) g : (a1 ~ a2 : A/R) == (a1' ~ a2' : B/R)


defn
G ; D |- g : A ~ B : R ::  :: AnnDefEq :: 'An_'
{{ com coercion between types }}
{{ tex [[G]]; [[D]] \vdash [[g]] [[:]] [[A]] \sim_[[R]] [[B]] }}
by

|- G
c: a ~ b : A/R in G
c in D
------------------- :: Assn
G ; D |- c : a ~ b : R

G |- a : A/R
----------------------------- :: Refl
G ; D |- refl a : a ~ a : R

G |- a : A/R
G |- b : B/R
|a|R = |b|R
G ; dom G |- g : A ~ B : R
----------------------------- :: EraseEq
G ; D |- refl2 a b g : a ~ b : R


G |- b : B/R
G |- a : A/R
[ G ; dom G |- g1 : B ~ A : R ]
G ; D |- g : b ~ a : R
-------------------------- :: Sym
G ; D |- sym g : a ~ b : R

G ; D |- g1 : a ~ a1 : R
G ; D |- g2 : a1 ~ b : R
[ G |- a : A/R ]
[ G |- a1 : A1/R ]
[ G ; dom G |- g3 : A ~ A1 : R ]
------------------------------------- :: Trans
G ; D |- (g1 ; g2) : a ~ b : R


G |- a1 : B0/R
G |- a2 : B1/R
|B0|R = |B1|R
|= |a1|R > |a2|R / R
--------------------------------  :: Beta
G ; D |- red a1 a2 : a1 ~ a2 : R


%% Note: need to include {x/x} to emphasize that x is free in B2 for
%% the locally nameless backend.
%% Need all three assns, so that we know A1, A2, B1, B2, B3 all have kind TYPE
G ; D |- g1 : A1 ~ A2 : R'
G, x : A1/R ; D |- g2 : B1 ~ (# B2 {{{ x / x }}} #) : R'
B3 = B2 { x |>R' sym g1 / x }
G |- all rho x:A1/R -> B1 : TYPE/R'
G |- all rho x:A1/R -> B2 : TYPE/R'
G |- all rho x:A2/R -> B3 : TYPE/R'
[R <= R']
---------------------------------------------------------- :: PiCong
G ; D |- all rho R x:g1 -> g2 : (all rho x:A1/R -> B1) ~ (all rho x:A2/R -> B3) : R'

G ; D |- g1 : A1 ~ A2 : R
G, x : A1/R ; D |- g2 : b1 ~ (# b2 {{{x / x}}} #) : R'
b3 = b2 { x |>R' sym g1 / x }
[ G |- A1 : TYPE/R ]
G |- A2 : TYPE/R
rho => check x in | b1 |R'
rho => check x in | b3 |R'
[G |- (\ rho x:A1/R. b2) : B/R']
[R <= R' ]
------------------------------------------------------------------ :: AbsCong
G ; D |- (\rho R x:g1. g2) : (\ rho x:A1/R. b1) ~ (\ rho x :A2/R. b3) : R'

% really want heterogenous equality here.
%% NOTE: we know that G |- g3 : A ~ B  must hold (b/c reg), but adding it as
%% an extra assumption for the erasure proof.
G ; D |- g1 : a1 ~ b1 : R'
G ; D |- g2 : a2 ~ b2 : R
G |- a1 rho R a2 : A/R'
G |- b1 rho R b2 : B/R'
[ G ; dom G |- g3 : A ~ B : R' ]
-------------------------------------- :: AppCong
G ; D |- g1 rho R g2 : a1 rho R a2 ~ b1 rho R b2 : R'


G ; D |- g : all rho x:A1/R -> B1 ~ all rho x:A2/R -> B2 : R'
--------------------------------------- :: PiFst
G ; D |- piFst g : A1 ~ A2 : R

G ; D |- g1 : all rho x:A1/R -> B1  ~ all rho x:A2/R -> B2 : R'
G ; D |- g2 : a1 ~ a2 : R
G |- a1 : A1/R
G |- a2 : A2/R
--------------------------------------- :: PiSnd
G ; D |- g1 @ g2 : (# B1 {a1 /x} #) ~ (# B2 {a2/x} #) : R'


G ; D |- g1 : a1 ~ b1 : A1/R == a2 ~ b2 : A2/R
G, c:a1 ~ b1 : A1/R ; D |- g3 : B1 ~ (# B2 {{{c/c}}} #) : R'
B3 = B2 { c |>R' sym g1 / c }
G |- all c:a1 ~ b1 : A1/R . B1 : TYPE/R'
[G |- all c:a2 ~ b2 : A2/R . B3 : TYPE/R']
G |- all c:a1 ~ b1 : A1/R . B2 : TYPE/R'
----------------------------------------------------- :: CPiCong
G ; D |- (all c: g1. g3) : (all c:a1 ~ b1 : A1/R. B1) ~ (all c:a2 ~ b2 : A2/R. B3) : R


G ; D |- g1 : b0 ~ b1 : A1/R == b2 ~ b3 : A2/R
G, c:b0 ~ b1 : A1/R ; D |- g3 : a1 ~ (# a2{{{c/c}}} #) : R'
a3 = a2 { c |>R' sym g1 / c }
%% To know that the two types are equal, we need to know
%% that the range types can be shown identical without using
%% the assumption c:phi1. This is a stronger property than
%% regularity implies.
G |- (/\ c:b0 ~ b1 : A1/R. a1) : all c:b0 ~ b1 : A1/R. B1/R'
G |- (/\ c:b0 ~ b1 : A1/R. a2) : B/R'
G |- (/\ c:b2 ~ b3 : A2/R. a3) : all c:b2 ~ b3 : A2/R. B2/R'
G ; dom G |- g4 : all c:b0 ~ b1 : A1/R. B1 ~ all c:phi2. B2 : R'
---------------------------------------------------------------- :: CAbsCong
G ; D |- (\ c: g1. g3 @ g4) : (/\ c:b0 ~ b1 : A1/R. a1) ~ (/\ c:b2 ~ b3 : A2/R. a3) : R'


G ; D |- g1 : a1 ~ b1 : R
G ; dom G |- g2 : a2 ~ b2 : R'
G ; dom G |- g3 : a3 ~ b3 : R'
G |- a1 [g2] : A / R
G |- b1 [g3] : B / R
[ G ; dom G |- g4 : A ~ B : R ]
-------------------------------------- :: CAppCong
G ; D |- g1 (g2, g3) : a1 [ g2 ]  ~ b1 [ g3 ] : R


G ; D |- g1 : (all c1:a~a':A/R. B1) ~ (all c2:b~b':B/R'. B2) : R0
G ; dom G |- g2 : a~a' : R
G ; dom G |- g3 : b~b' : R'
-------------------------------------------------- :: CPiSnd
G ; D |- g1 @ (g2, g3) : B1 { g2 / c1 } ~ B2 { g3 / c2 } : R0


G ; D |- g1 : a~a' : R1
G ; D |- g2 : a~a' :A/R1 == b~b' : B/R1
--------------------------------------- :: Cast
G ; D |- g1 |>R1 g2 : b~b' : R1


G ; D |- g : (a~a' : A/R) == (b~b' : B/R)
---------------------------------- :: IsoSnd
G ; D |- isoSnd g : A ~ B : R

G ; D |- g : a ~ b : R1
R1 <= R2
---------------------------------------- :: Sub
G ; D |- sub g : a ~ b : R2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defn
|- G ::      :: AnnCtx :: 'An_'
{{ com context wellformedness }}
by


---------- :: Empty
|- empty

|- G
G |- A : TYPE/R
x notin dom G
--------------------- :: ConsTm
|- G, x : A/R

|- G
G |- phi ok
c notin dom G
-------------------- :: ConsCo
|- G, c:phi

defn
|- S ::    :: AnnSig :: 'An_Sig_'
{{ com signature wellformedness }}
by

------------ :: Empty
|- emptyS


|- S
empty |- A : TYPE/R
empty |- a : A/R
F notin dom S
---------------- :: ConsAx
|- S, F ~ a  : A/R


defns
  Jred :: '' ::=

defn
G |- a ~>h b / R ::   :: head_reduction :: 'An_'
{{ com single-step, weak head reduction to
   values for annotated language }}
% NOTE: this reduction needs a context for the the
% two push rules. We need to read the coercion proofs
% to know what type annotations to use after the push.
by

G |- a ~>h a' / R1
-------------------------  :: AppLeft
G |- a rho R b ~>h a' rho R b  / R1

Value R (\rho x:A/R.w)
-----------------------------------------  :: AppAbs
G |- (\rho x:A/R.w) rho R a ~>h w { a / x} / R


G |- a  ~>h a' / R
-----------------------------   :: CAppLeft
G |- a [g]  ~>h a' [g] / R


------------------------------------  :: CAppCAbs
G |- (/\c:phi.b) [g] ~>h b { g / c} / R

G |- A : TYPE/R
G, x : A/R |- b ~>h b' / R1
------------------------------------------- :: AbsTerm
G |- (\- x:A/R. b) ~>h (\- x:A/R. b') /R1


F ~ a : A/R in an_toplevel
------------------------- :: Axiom
G |- F ~>h a / R


G |- a ~>h a' / R
---------------------------- :: ConvTerm
 G |- a |>R1 g ~>h a' |>R1 g / R


Value R v
------------------------------------- :: Combine
G |- (v |>R2 g1) |>R2 g2 ~>h v |>R2 (g1 ; g2) / R

% Not used (or needed)

%   G ; dom G |- g : all rho x1:A1 -> B1 ~ all rho x2:A2 -> B2
%   a1 = a { x2 |> sym (piFst g) / x1 }
%   g2 = g @ refl2 (# x2 |> sym (piFst g) #) x2 (# piFst g #)
% ------------------------------------------------------------------------- :: Push
%   G |- ( (\rho x1:A1.a) |> g ) rho b ~>h (\rho x2:A2. (a1 |> g2)) rho b

%   G ; dom G |- g : all c1:phi1. A1 ~ all c2:phi2. A2
%   a1 = a { c2 |> sym (cpiFst g)  / c1 }
%   g2 = g @ (c2 |> sym (cpiFst g), c2)
% ------------------------------------------------------------------ :: CPush
%   G |- ( (/\c1:phi1.a) |> g ) [g1] ~>h (/\c2:phi2. (a1 |> g2)) [g1]



Value R v
G ; dom G |- g : all rho x1: A1/R -> B1 ~ all rho x2: A2/R -> B2 : R'
b' = b |>R' sym (piFst g)
g' = g @ refl2 b' b (piFst g)
---------------------------------------------------------- :: Push
G |- (v |>R' g) rho R b ~>h ((v rho R b') |>R' g') / R


Value R v
G ; dom G |- g : all c1:a1 ~ b1 : B1/R. A1 ~ all c2:a2 ~ b2 : B2/R. A2 : R'
g1' = g1 |>R' sym (cpiFst g)
g' = g @ ( g1' , g1 )
-------------------------------------------------------- :: CPush
G |- (v |>R' g) [g1] ~>h ((v [g1']) |>R' g') / R
